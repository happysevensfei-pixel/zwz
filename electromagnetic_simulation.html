<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é€ ç‰©ä¸» 4.0 - ç”µç£åœºç²’å­è¿åŠ¨æ¨¡æ‹Ÿå™¨</title>
    <link rel="icon" href="/zwz/logo.jpg" type="image/jpeg">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            background-color: black;
            overflow: hidden;
            height: 100%;
            font-family: 'Segoe UI', 'Arial', sans-serif;
        }

        #canvas {
            display: block;
            background-color: black;
            cursor: crosshair;
        }

        /* æ‚¬æµ®çª—æ ·å¼ - ä¸inter.htmlä¸€è‡´ */
        .control-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 320px;
            min-height: 400px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(20, 20, 20, 0.8));
            backdrop-filter: blur(25px) saturate(1.5);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow:
                0 20px 40px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            padding: 20px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 15px;
            opacity: 1;
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            cursor: move;
            user-select: none;
        }

        .control-panel h3 {
            color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: linear-gradient(45deg, #fff, #aaa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .control-group {
            margin-bottom: 18px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: #cccccc;
            font-weight: 500;
        }

        .control-group input,
        .control-group select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 14px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
            background: rgba(255, 255, 255, 0.08);
        }

        /* æ–¹å‘é€‰æ‹©å™¨ */
        .direction-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .direction-btn {
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            cursor: pointer;
            text-align: center;
            font-size: 12px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .direction-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .direction-btn.active {
            background: rgba(79, 195, 247, 0.3);
            border-color: #4fc3f7;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.3);
        }

        /* åˆé€Ÿåº¦æ§åˆ¶ */
        .velocity-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .velocity-controls input {
            text-align: center;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .btn {
            width: 100%;
            height: 36px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 12px;
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px) scale(1.02);
            box-shadow:
                0 8px 20px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.1);
        }

        .btn:active {
            transform: translateY(0) scale(0.98);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }


        /* å…³é—­æŒ‰é’® */
        .close-button {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
        }

        .close-button:hover {
            background: linear-gradient(135deg, rgba(255, 100, 100, 0.3), rgba(255, 50, 50, 0.2));
            border-color: rgba(255, 100, 100, 0.3);
            color: rgba(255, 255, 255, 1);
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 4px 12px rgba(255, 100, 100, 0.3);
        }

        /* æ‹–æ‹½ç›¸å…³æ ·å¼ */
        .control-panel.dragging {
            cursor: move;
            user-select: none;
            transition: none;
        }

        .control-panel.dragging * {
            pointer-events: none;
        }

        .control-panel.dragging .close-button {
            pointer-events: auto;
        }

        .control-panel .drag-handle {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 30px;
            cursor: move;
            z-index: 10;
            border-radius: 16px 16px 0 0;
        }

        .control-panel .drag-handle:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        /* æ‹–æ‹½æ—¶çš„è§†è§‰åé¦ˆ */
        .control-panel.dragging {
            box-shadow:
                0 25px 50px rgba(0, 0, 0, 0.5),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        /* å³ä¸‹è§’è·³è½¬æŒ‰é’® */
        #centerButton {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, rgba(0, 150, 255, 0.8), rgba(0, 100, 200, 0.6));
            backdrop-filter: blur(15px) saturate(1.2);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow:
                0 8px 25px rgba(0, 150, 255, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.1);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #centerButton:hover {
            transform: scale(1.1);
            background: linear-gradient(135deg, rgba(0, 200, 255, 0.9), rgba(0, 150, 255, 0.7));
            box-shadow:
                0 12px 35px rgba(0, 150, 255, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.2);
        }

        #centerButton:active {
            transform: scale(0.95);
        }

        /* å³ä¸‹è§’åæ ‡ç³»æŒ‰é’® */
        #coordinateButton {
            position: fixed;
            bottom: 20px;
            right: 90px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, rgba(100, 100, 100, 0.8), rgba(60, 60, 60, 0.6));
            backdrop-filter: blur(15px) saturate(1.2);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow:
                0 8px 25px rgba(100, 100, 100, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.1);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #coordinateButton:hover {
            transform: scale(1.1);
            background: linear-gradient(135deg, rgba(120, 120, 120, 0.9), rgba(80, 80, 80, 0.7));
            box-shadow:
                0 12px 35px rgba(100, 100, 100, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.2);
        }

        #coordinateButton:active {
            transform: scale(0.95);
        }

        #coordinateButton.active {
            background: linear-gradient(135deg, rgba(0, 150, 255, 0.8), rgba(0, 100, 200, 0.6));
            border-color: rgba(0, 150, 255, 0.3);
            box-shadow:
                0 8px 25px rgba(0, 150, 255, 0.3),
                0 0 0 1px rgba(0, 150, 255, 0.2);
        }

        /* æ¯›ç»ç’ƒæç¤ºä¿¡æ¯ */
        .instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(20px) saturate(1.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            color: white;
            font-size: 13px;
            max-width: 320px;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .instructions h4 {
            color: #ffffff;
            margin-bottom: 12px;
            font-weight: 300;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .instructions ul {
            list-style: none;
            padding-left: 0;
        }

        .instructions li {
            margin-bottom: 6px;
            color: #cccccc;
        }

        /* æ‹–æ‹½é¢„è§ˆ */
        .drag-preview {
            position: absolute;
            border: 2px dashed rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.05);
            pointer-events: none;
            z-index: 999;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        /* ç²’å­ä¿¡æ¯æ˜¾ç¤º */
        .particle-info {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(20px) saturate(1.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            color: white;
            font-size: 13px;
            max-width: 220px;
            z-index: 1000;
            display: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .particle-info.show {
            display: block;
        }

        .particle-info h4 {
            color: #ffffff;
            margin-bottom: 12px;
            font-weight: 300;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        /* æ•°å€¼æ˜¾ç¤º */
        .value-display {
            color: #4fc3f7;
            font-weight: 600;
        }

        /* å½©è™¹è½¨è¿¹æ ·å¼ */
        .trail {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .control-panel {
                min-width: 280px;
                padding: 20px;
            }

            .mode-indicator {
                right: 10px;
                top: 10px;
                padding: 12px 16px;
                font-size: 12px;
            }

            .instructions {
                bottom: 10px;
                left: 10px;
                max-width: 280px;
                padding: 16px;
            }
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>

    <!-- ä¸­å¤®è·³è½¬æŒ‰é’® -->
    <button id="centerButton" onclick="window.location.href='inter.html'">è·³è½¬</button>

    <!-- å³ä¸‹è§’åæ ‡ç³»æŒ‰é’® -->
    <button id="coordinateButton" onclick="toggleCoordinateSystem()">ğŸ“</button>

    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="control-panel" id="controlPanel">
        <div class="drag-handle"></div>
        <button class="close-button" onclick="document.getElementById('controlPanel').style.display='none'">Ã—</button>
        <h3>ç”µç£åœºç²’å­æ¨¡æ‹Ÿå™¨</h3>

        <div class="control-group">
            <label>å½“å‰æ¨¡å¼:</label>
            <select id="modeSelect">
                <option value="electric">ç”µåœºæ¨¡å¼</option>
                <option value="magnetic">ç£åœºæ¨¡å¼</option>
                <option value="particle">ç²’å­æ¨¡å¼</option>
            </select>
        </div>

        <div class="control-group" id="fieldControls">
            <label>åœºå¼ºåº¦: <span class="value-display" id="fieldStrengthValue">50</span></label>
            <input type="range" id="fieldStrength" min="-100" max="100" value="50">

            <label style="margin-top: 15px;">åœºå½¢çŠ¶:</label>
            <div class="direction-selector" id="shapeSelector">
                <div class="direction-btn active" data-shape="rectangle">â¬œ çŸ©å½¢</div>
                <div class="direction-btn" data-shape="circle">â­• åœ†å½¢</div>
                <div class="direction-btn" data-shape="triangle">ğŸ”º ä¸‰è§’å½¢</div>
                <div class="direction-btn" data-shape="semicircle">ğŸŒ™ åŠåœ†</div>
            </div>

            <label style="margin-top: 15px;">åœºæ–¹å‘:</label>
            <div class="direction-selector" id="fieldDirectionSelector">
                <div class="direction-btn" data-direction="right">â†’ å³</div>
                <div class="direction-btn" data-direction="left">â† å·¦</div>
                <div class="direction-btn" data-direction="up">â†‘ ä¸Š</div>
                <div class="direction-btn active" data-direction="down">â†“ ä¸‹</div>
            </div>
            <div class="direction-selector" id="magneticDirectionSelector" style="display: none; margin-top: 10px;">
                <div class="direction-btn active" data-magnetic-direction="out">âŠ™ ç©¿å‡ºå±å¹•</div>
                <div class="direction-btn" data-magnetic-direction="in">âŠ— è¿›å…¥å±å¹•</div>
            </div>

            <label style="margin-top: 15px;">SVGå¯¼å…¥:</label>
            <input type="file" id="svgFileInput" accept=".svg" style="display: none;">
            <button class="btn" onclick="document.getElementById('svgFileInput').click()">ğŸ“ å¯¼å…¥SVG</button>
        </div>

        <div class="control-group" id="particleControls" style="display: none;">
            <label>ç²’å­è´¨é‡:</label>
            <input type="number" id="particleMass" value="1" min="0.1" max="10" step="0.1">

            <label style="margin-top: 10px;">ç”µè·é‡:</label>
            <input type="number" id="particleCharge" value="1" min="-10" max="10" step="0.1">

            <label style="margin-top: 15px;">åˆé€Ÿåº¦å¤§å°:</label>
            <input type="number" id="initialSpeed" value="0" step="0.1" min="0">

            <label style="margin-top: 15px;">é€Ÿåº¦è§’åº¦(åº¦):</label>
            <input type="number" id="initialAngle" value="90" min="0" max="360" step="1">

            <div class="velocity-preview" style="margin-top: 15px; text-align: center;">
                <div
                    style="display: inline-block; padding: 8px; border-radius: 8px; background: rgba(255,255,255,0.1);">
                    <span id="velocityVectorDisplay">â†’ 0Â°</span>
                </div>
            </div>
        </div>

        <div class="control-group" id="gravityControls">
            <label>é‡åŠ›å¼ºåº¦: <span class="value-display" id="gravityValue">0</span></label>
            <input type="range" id="gravityStrength" min="0" max="100" value="0">

            <label style="margin-top: 15px;">é‡åŠ›æ–¹å‘:</label>
            <div class="direction-selector">
                <div class="direction-btn" data-gravity-direction="right">â†’ å³</div>
                <div class="direction-btn" data-gravity-direction="left">â† å·¦</div>
                <div class="direction-btn" data-gravity-direction="up">â†‘ ä¸Š</div>
                <div class="direction-btn active" data-gravity-direction="down">â†“ ä¸‹</div>
            </div>
        </div>

        <div class="button-group">
            <button class="btn btn-success" id="startBtn">å¼€å§‹æ¨¡æ‹Ÿ</button>
            <button class="btn btn-secondary" id="pauseBtn">æš‚åœ</button>
            <button class="btn btn-primary" id="resetBtn">é‡ç½®</button>
        </div>
    </div>




    <!-- ç²’å­ä¿¡æ¯ -->
    <div class="particle-info" id="particleInfo">
        <h4>ç²’å­ä¿¡æ¯</h4>
        <div id="particleDetails"></div>
    </div>

    <!-- æ‹–æ‹½é¢„è§ˆ -->
    <div class="drag-preview" id="dragPreview"></div>


    <script>
        class ElectromagneticSimulation {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.setupCanvas();

                // æ¨¡æ‹ŸçŠ¶æ€
                this.isRunning = false;
                this.isPaused = false;
                this.mode = 'electric'; // electric, magnetic, particle

                // ç‰©ç†å¯¹è±¡
                this.fields = []; // ç”µåœºå’Œç£åœº
                this.particles = []; // ç²’å­
                this.trails = []; // è½¨è¿¹

                // é¼ æ ‡çŠ¶æ€
                this.isDragging = false;
                this.dragStart = { x: 0, y: 0 };
                this.dragEnd = { x: 0, y: 0 };
                this.selectedField = null;

                // å½“å‰åœºæ–¹å‘
                this.currentFieldDirection = { x: 0, y: 0 }; // é»˜è®¤å‘ä¸‹
                this.currentVelocityDirection = { x: 0, y: 0 }; // é»˜è®¤å‘ä¸‹
                this.currentMagneticDirection = 'out'; // é»˜è®¤ç©¿å‡ºå±å¹•
                this.currentGravityDirection = { x: 0, y: 0 }; // é»˜è®¤å‘ä¸‹
                this.currentShape = 'rectangle'; // é»˜è®¤çŸ©å½¢
                this.showCoordinateSystem = false; // åæ ‡ç³»æ˜¾ç¤ºçŠ¶æ€

                // åŠ¨ç”»
                this.animationId = null;
                this.lastTime = 0;

                this.initEventListeners();
                this.initDragFunctionality();
                this.startAnimation();
            }

            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                });
            }

            initEventListeners() {
                // æ¨¡å¼åˆ‡æ¢
                document.getElementById('modeSelect').addEventListener('change', (e) => {
                    this.mode = e.target.value;
                    this.updateModeIndicator();
                    this.toggleControls();
                });

                // åœºå¼ºåº¦æ§åˆ¶
                document.getElementById('fieldStrength').addEventListener('input', (e) => {
                    document.getElementById('fieldStrengthValue').textContent = e.target.value;
                });

                // é‡åŠ›å¼ºåº¦æ§åˆ¶
                document.getElementById('gravityStrength').addEventListener('input', (e) => {
                    document.getElementById('gravityValue').textContent = e.target.value;
                });

                // åœºæ–¹å‘é€‰æ‹©
                document.querySelectorAll('[data-direction]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-direction]').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');

                        const direction = e.target.dataset.direction;
                        this.currentFieldDirection = this.getDirectionVector(direction);
                    });
                });

                // ç£åœºæ–¹å‘é€‰æ‹©
                document.querySelectorAll('[data-magnetic-direction]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-magnetic-direction]').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');

                        this.currentMagneticDirection = e.target.dataset.magneticDirection;
                    });
                });

                // å½¢çŠ¶é€‰æ‹©
                document.querySelectorAll('[data-shape]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-shape]').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');

                        this.currentShape = e.target.dataset.shape;
                    });
                });

                // SVGæ–‡ä»¶å¯¼å…¥
                document.getElementById('svgFileInput').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.loadSVGShape(file);
                    }
                });

                // ç²’å­é€Ÿåº¦æ–¹å‘é€‰æ‹©
                document.querySelectorAll('[data-velocity-direction]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-velocity-direction]').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');

                        const direction = e.target.dataset.velocityDirection;
                        this.currentVelocityDirection = this.getDirectionVector(direction);
                    });
                });

                // é‡åŠ›æ–¹å‘é€‰æ‹©
                document.querySelectorAll('[data-gravity-direction]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-gravity-direction]').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');

                        const direction = e.target.dataset.gravityDirection;
                        this.currentGravityDirection = this.getDirectionVector(direction);
                    });
                });

                // æŒ‰é’®äº‹ä»¶
                document.getElementById('startBtn').addEventListener('click', () => this.startSimulation());
                document.getElementById('pauseBtn').addEventListener('click', () => this.pauseSimulation());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetSimulation());

                // é¼ æ ‡äº‹ä»¶
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('dblclick', (e) => this.handleDoubleClick(e));


                // åˆå§‹åŒ–
                this.updateModeIndicator();
                this.toggleControls();
            }

            initDragFunctionality() {
                const panel = document.getElementById('controlPanel');
                let isDragging = false;
                let startX, startY, startLeft, startTop;

                panel.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('drag-handle') || e.target === panel) {
                        isDragging = true;
                        panel.classList.add('dragging');

                        const rect = panel.getBoundingClientRect();
                        startX = e.clientX;
                        startY = e.clientY;
                        startLeft = rect.left;
                        startTop = rect.top;

                        e.preventDefault();
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const deltaX = e.clientX - startX;
                        const deltaY = e.clientY - startY;

                        panel.style.left = (startLeft + deltaX) + 'px';
                        panel.style.top = (startTop + deltaY) + 'px';
                        panel.style.transform = 'none';
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        panel.classList.remove('dragging');
                    }
                });
            }

            getDirectionVector(direction) {
                const vectors = {
                    'right': { x: 1, y: 0 },
                    'left': { x: -1, y: 0 },
                    'up': { x: 0, y: -1 },
                    'down': { x: 0, y: 1 }
                };
                return vectors[direction] || { x: 0, y: 1 };
            }

            updateModeIndicator() {
                // æ¨¡å¼æŒ‡ç¤ºå™¨å·²ç§»é™¤ï¼Œä½¿ç”¨æ‚¬æµ®çª—å†…çš„é€‰æ‹©å™¨
            }

            toggleControls() {
                const fieldControls = document.getElementById('fieldControls');
                const particleControls = document.getElementById('particleControls');
                const fieldDirectionSelector = document.getElementById('fieldDirectionSelector');
                const magneticDirectionSelector = document.getElementById('magneticDirectionSelector');

                if (this.mode === 'particle') {
                    fieldControls.style.display = 'none';
                    particleControls.style.display = 'block';
                } else {
                    fieldControls.style.display = 'block';
                    particleControls.style.display = 'none';

                    // æ˜¾ç¤ºå¯¹åº”çš„æ–¹å‘é€‰æ‹©å™¨
                    if (this.mode === 'electric') {
                        fieldDirectionSelector.style.display = 'grid';
                        magneticDirectionSelector.style.display = 'none';
                    } else if (this.mode === 'magnetic') {
                        fieldDirectionSelector.style.display = 'none';
                        magneticDirectionSelector.style.display = 'grid';
                    }
                }
            }

            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (this.mode === 'particle') return;

                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åœ¨ç°æœ‰åœºä¸Š
                this.selectedField = this.getFieldAt(x, y);

                if (this.selectedField) {
                    // å¼€å§‹ç§»åŠ¨åœº
                    this.isDragging = true;
                    this.dragStart = { x, y };
                } else {
                    // å¼€å§‹åˆ›å»ºæ–°åœº
                    this.isDragging = true;
                    this.dragStart = { x, y };
                    this.dragEnd = { x, y };
                }
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (this.isDragging) {
                    if (this.selectedField) {
                        // ç§»åŠ¨ç°æœ‰åœº
                        const dx = x - this.dragStart.x;
                        const dy = y - this.dragStart.y;

                        this.selectedField.x += dx;
                        this.selectedField.y += dy;
                        this.selectedField.endX += dx;
                        this.selectedField.endY += dy;

                        this.dragStart = { x, y };
                    } else {
                        // æ›´æ–°æ‹–æ‹½é¢„è§ˆ
                        this.dragEnd = { x, y };
                        this.updateDragPreview();
                    }
                }
            }

            handleMouseUp(e) {
                if (!this.isDragging) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (this.selectedField) {
                    // å®Œæˆç§»åŠ¨åœº
                    this.selectedField = null;
                } else {
                    // åˆ›å»ºæ–°åœº
                    this.dragEnd = { x, y };
                    const width = Math.abs(this.dragEnd.x - this.dragStart.x);
                    const height = Math.abs(this.dragEnd.y - this.dragStart.y);

                    if (width > 10 && height > 10) {
                        this.createField(this.dragStart, this.dragEnd);
                    }
                }

                this.isDragging = false;
                this.hideDragPreview();
            }

            handleDoubleClick(e) {
                if (this.mode !== 'particle') return;

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const mass = parseFloat(document.getElementById('particleMass').value);
                const charge = parseFloat(document.getElementById('particleCharge').value);
                const speed = parseFloat(document.getElementById('initialSpeed').value) || 0;
                const angle = parseFloat(document.getElementById('initialAngle').value) || 90;

                // å°†è§’åº¦è½¬æ¢ä¸ºå¼§åº¦
                const radians = angle * Math.PI / 180;
                // ä¿®æ­£åæ ‡ç³»é—®é¢˜ï¼šå®é™…äº¤æ¢sinå’Œcosåº”ç”¨ï¼Œä½¿0åº¦å¯¹åº”å‘å³ï¼ˆxæ­£æ–¹å‘ï¼‰è¿è¡Œ
                const vx = speed * Math.sin(radians);
                const vy = speed * Math.cos(radians);

                this.createParticle(x, y, mass, charge, vx, vy);
            }

            // æ›´æ–°é€Ÿåº¦å‘é‡æ˜¾ç¤º
            updateVelocityDisplay() {
                const speed = parseFloat(document.getElementById('initialSpeed').value) || 0;
                const angle = parseFloat(document.getElementById('initialAngle').value) || 90;
                document.getElementById('velocityVectorDisplay').textContent =
                    `â†’ ${angle}Â° (${speed.toFixed(1)} m/s)`;
            }

            getRandomColor(type, strength) {
                const hue = Math.floor(Math.random() * 360);
                if (type === 'electric') {
                    return strength > 0 ? `hsl(${hue}, 80%, 70%)` : `hsl(${(hue + 180) % 360}, 80%, 70%)`;
                } else {
                    return strength > 0 ? `hsl(${hue}, 80%, 70%)` : `hsl(${(hue + 30) % 360}, 80%, 70%)`;
                }
            }

            createField(start, end) {
                const strength = parseFloat(document.getElementById('fieldStrength').value);
                const width = Math.abs(end.x - start.x);
                const height = Math.abs(end.y - start.y);

                const field = {
                    id: Date.now(),
                    type: this.mode,
                    shape: this.currentShape,
                    centerX: (start.x + end.x) / 2,
                    centerY: (start.y + end.y) / 2,
                    width: width,
                    height: height,
                    x: Math.min(start.x, end.x),
                    y: Math.min(start.y, end.y),
                    endX: Math.max(start.x, end.x),
                    endY: Math.max(start.y, end.y),
                    strength: strength,
                    direction: { ...this.currentFieldDirection },
                    magneticDirection: this.currentMagneticDirection,
                    svgPath: null,
                    color: this.getRandomColor(this.mode, strength)
                };

                this.fields.push(field);
            }

            createParticle(x, y, mass, charge, vx = 0, vy = 0) {
                const particle = {
                    id: Date.now(),
                    x: x,
                    y: y,
                    vx: vx,
                    vy: vy,
                    mass: mass,
                    charge: charge,
                    trail: [],
                    color: this.getParticleColor(charge)
                };

                this.particles.push(particle);
            }

            getParticleColor(charge) {
                if (charge > 0) return '#ff6b6b'; // çº¢è‰² - æ­£ç”µè·
                if (charge < 0) return '#4ecdc4'; // é’è‰² - è´Ÿç”µè·
                return '#ffd93d'; // é»„è‰² - ä¸­æ€§
            }

            getFieldAt(x, y) {
                return this.fields.find(field =>
                    x >= field.x && x <= field.endX &&
                    y >= field.y && y <= field.endY
                );
            }

            // è·å–ç²’å­æ‰€åœ¨ä½ç½®çš„æ‰€æœ‰åœº
            getFieldsAt(x, y) {
                return this.fields.filter(field => {
                    return this.isPointInField(x, y, field);
                });
            }

            isPointInField(x, y, field) {
                switch (field.shape) {
                    case 'rectangle':
                        return x >= field.x && x <= field.endX && y >= field.y && y <= field.endY;

                    case 'circle':
                        const radius = Math.min(field.width, field.height) / 2;
                        const dx = x - field.centerX;
                        const dy = y - field.centerY;
                        return (dx * dx + dy * dy) <= (radius * radius);

                    case 'triangle':
                        return this.isPointInTriangle(x, y, field);

                    case 'semicircle':
                        return this.isPointInSemicircle(x, y, field);

                    case 'svg':
                        return this.isPointInSVGPath(x, y, field);

                    default:
                        return x >= field.x && x <= field.endX && y >= field.y && y <= field.endY;
                }
            }

            isPointInTriangle(x, y, field) {
                const { centerX, centerY, width, height } = field;
                const x1 = centerX, y1 = centerY - height / 2; // é¡¶ç‚¹
                const x2 = centerX - width / 2, y2 = centerY + height / 2; // å·¦ä¸‹è§’
                const x3 = centerX + width / 2, y3 = centerY + height / 2; // å³ä¸‹è§’

                const denom = (y2 - y3) * (x1 - x3) + (x3 - x2) * (y1 - y3);
                const a = ((y2 - y3) * (x - x3) + (x3 - x2) * (y - y3)) / denom;
                const b = ((y3 - y1) * (x - x3) + (x1 - x3) * (y - y3)) / denom;
                const c = 1 - a - b;

                return a >= 0 && b >= 0 && c >= 0;
            }

            isPointInSemicircle(x, y, field) {
                const { centerX, centerY, width, height } = field;
                const radius = Math.min(width, height) / 2;
                const dx = x - centerX;
                const dy = y - centerY;

                // æ£€æŸ¥æ˜¯å¦åœ¨åœ†å½¢å†…
                if ((dx * dx + dy * dy) > (radius * radius)) return false;

                // æ£€æŸ¥æ˜¯å¦åœ¨åŠåœ†å†…ï¼ˆå‡è®¾ä¸ŠåŠåœ†ï¼‰
                return dy <= centerY;
            }

            isPointInSVGPath(x, y, field) {
                if (!field.svgPath) return false;

                // ç®€åŒ–çš„SVGè·¯å¾„æ£€æµ‹ï¼Œè¿™é‡Œéœ€è¦æ ¹æ®å®é™…çš„SVGè·¯å¾„å®ç°
                // å¯ä»¥ä½¿ç”¨Canvasçš„isPointInPathæ–¹æ³•
                const ctx = this.ctx;
                ctx.beginPath();
                ctx.setTransform(1, 0, 0, 1, 0, 0); // é‡ç½®å˜æ¢
                ctx.translate(field.centerX, field.centerY);
                ctx.scale(field.width / 100, field.height / 100); // å‡è®¾SVGæ˜¯100x100

                // è¿™é‡Œéœ€è¦è§£æSVGè·¯å¾„å¹¶ç»˜åˆ¶åˆ°canvas
                // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦å®Œæ•´çš„SVGè·¯å¾„è§£æå™¨
                return false; // æš‚æ—¶è¿”å›falseï¼Œéœ€è¦å®Œæ•´å®ç°
            }

            loadSVGShape(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const svgText = e.target.result;
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
                    const svgElement = svgDoc.querySelector('svg');

                    if (svgElement) {
                        const paths = svgElement.querySelectorAll('path');
                        if (paths.length > 0) {
                            const pathData = paths[0].getAttribute('d');

                            // åˆ›å»ºä¸€ä¸ªSVGå½¢çŠ¶çš„åœº
                            const field = {
                                id: Date.now(),
                                type: this.mode,
                                shape: 'svg',
                                centerX: 400,
                                centerY: 300,
                                width: 200,
                                height: 200,
                                strength: parseFloat(document.getElementById('fieldStrength').value),
                                direction: { ...this.currentFieldDirection },
                                magneticDirection: this.currentMagneticDirection,
                                svgPath: pathData,
                        color: this.getRandomColor(this.mode, parseFloat(document.getElementById('fieldStrength').value))
                            };

                            this.fields.push(field);
                        }
                    }
                };
                reader.readAsText(file);
            }

            updateDragPreview() {
                const preview = document.getElementById('dragPreview');
                const left = Math.min(this.dragStart.x, this.dragEnd.x);
                const top = Math.min(this.dragStart.y, this.dragEnd.y);
                const width = Math.abs(this.dragEnd.x - this.dragStart.x);
                const height = Math.abs(this.dragEnd.y - this.dragStart.y);

                preview.style.left = left + 'px';
                preview.style.top = top + 'px';
                preview.style.width = width + 'px';
                preview.style.height = height + 'px';
                preview.style.display = 'block';

                // æ ¹æ®å½¢çŠ¶è®¾ç½®ä¸åŒçš„é¢„è§ˆæ ·å¼
                const strength = parseFloat(document.getElementById('fieldStrength').value);
                const color = this.mode === 'electric' ?
                    (strength > 0 ? '#ff6b6b' : '#4ecdc4') :
                    (strength > 0 ? '#6b73ff' : '#ff6b9d');

                preview.style.borderColor = color;
                preview.style.background = color + '20';

                // æ ¹æ®å½¢çŠ¶è°ƒæ•´è¾¹æ¡†åœ†è§’
                switch (this.currentShape) {
                    case 'circle':
                        preview.style.borderRadius = '50%';
                        break;
                    case 'triangle':
                        preview.style.borderRadius = '0';
                        preview.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
                        break;
                    case 'semicircle':
                        preview.style.borderRadius = '50% 50% 0 0';
                        break;
                    default:
                        preview.style.borderRadius = '8px';
                        preview.style.clipPath = 'none';
                }
            }

            hideDragPreview() {
                document.getElementById('dragPreview').style.display = 'none';
            }

            startSimulation() {
                this.isRunning = true;
                this.isPaused = false;
                document.getElementById('startBtn').textContent = 'è¿è¡Œä¸­...';
                document.getElementById('startBtn').disabled = true;
                document.getElementById('pauseBtn').disabled = false;
            }

            pauseSimulation() {
                this.isPaused = !this.isPaused;
                document.getElementById('pauseBtn').textContent = this.isPaused ? 'ç»§ç»­' : 'æš‚åœ';
            }

            resetSimulation() {
                this.isRunning = false;
                this.isPaused = false;
                this.particles = [];
                this.trails = [];
                document.getElementById('startBtn').textContent = 'å¼€å§‹æ¨¡æ‹Ÿ';
                document.getElementById('startBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
                document.getElementById('pauseBtn').textContent = 'æš‚åœ';
            }

            // ç‰©ç†è®¡ç®— - æ”¯æŒå¤šä¸ªåœºçš„å åŠ 
            calculateForces(particle) {
                let fx = 0, fy = 0;

                // 1. é‡åŠ›
                const gravityStrength = parseFloat(document.getElementById('gravityStrength').value);
                if (gravityStrength > 0) {
                    fx += particle.mass * gravityStrength * this.currentGravityDirection.x;
                    fy += particle.mass * gravityStrength * this.currentGravityDirection.y;
                }

                // 2. ç”µç£åœºåŠ›
                const fieldsAtPosition = this.getFieldsAt(particle.x, particle.y);

                for (const field of fieldsAtPosition) {
                    if (field.type === 'electric') {
                        // ç”µåœºåŠ› F = qE
                        fx += particle.charge * field.strength * field.direction.x;
                        fy += particle.charge * field.strength * field.direction.y;
                    } else if (field.type === 'magnetic') {
                        // ç£åœºåŠ› F = q(v Ã— B)
                        // åœ¨2Dä¸­ï¼Œç£åœºBå‚ç›´äºå±å¹•ï¼ˆzæ–¹å‘ï¼‰
                        const vx = particle.vx;
                        const vy = particle.vy;
                        const B = field.strength; // Bçš„å¤§å°

                        // æ ¹æ®ç£åœºæ–¹å‘ç¡®å®šBçš„æ–¹å‘
                        // ç©¿å‡ºå±å¹•ä¸º+zæ–¹å‘ï¼Œè¿›å…¥å±å¹•ä¸º-zæ–¹å‘
                        const B_direction = field.magneticDirection === 'out' ? 1 : -1;
                        const B_magnitude = B * B_direction;

                        // ç£åœºåŠ›å‚ç›´äºé€Ÿåº¦æ–¹å‘
                        // åœ¨2Dä¸­ï¼Œv Ã— B çš„ç»“æœæ˜¯å‚ç›´äºvå’ŒBçš„å‘é‡
                        // å¦‚æœBæŒ‡å‘+zï¼Œåˆ™v Ã— B = (vy, -vx)
                        // å¦‚æœBæŒ‡å‘-zï¼Œåˆ™v Ã— B = (-vy, vx)
                        fx += particle.charge * B_magnitude * vy;
                        fy -= particle.charge * B_magnitude * vx;
                    }
                }

                return { fx, fy };
            }

            updateParticles(deltaTime) {
                if (!this.isRunning || this.isPaused) return;

                // é™åˆ¶æ—¶é—´æ­¥é•¿ï¼Œç¡®ä¿æ•°å€¼ç¨³å®šæ€§
                const dt = Math.min(deltaTime / 1000, 0.016); // æœ€å¤§16msï¼Œçº¦60FPS

                for (const particle of this.particles) {
                    // ä¿å­˜åŸå§‹é€Ÿåº¦å¤§å°
                    const originalSpeed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);

                    // è®¡ç®—æ‰€æœ‰åŠ›ï¼ˆé‡åŠ› + ç”µç£åœºåŠ›ï¼‰
                    const force = this.calculateForces(particle);

                    // åº”ç”¨åŠ›: F = ma, æ‰€ä»¥ a = F/m
                    const ax = force.fx / particle.mass;
                    const ay = force.fy / particle.mass;

                    // ä½¿ç”¨æ”¹è¿›çš„æ•°å€¼ç§¯åˆ†ï¼ˆåŠéšå¼æ¬§æ‹‰æ³•ï¼‰
                    // å…ˆæ›´æ–°é€Ÿåº¦
                    particle.vx += ax * dt;
                    particle.vy += ay * dt;

                    // æ£€æŸ¥ç²’å­æ‰€åœ¨çš„åœºç¯å¢ƒ
                    const fieldsAtPosition = this.getFieldsAt(particle.x, particle.y);
                    const inMagneticField = fieldsAtPosition.some(f => f.type === 'magnetic');
                    const inElectricField = fieldsAtPosition.some(f => f.type === 'electric');
                    
                    // åªåœ¨çº¯ç£åœºç¯å¢ƒä¸­ï¼ˆæ²¡æœ‰ç”µåœºï¼‰æ‰ä¿æŒé€Ÿåº¦å¤§å°ä¸å˜
                    if (inMagneticField && !inElectricField && originalSpeed > 0) {
                        const newSpeed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
                        const scale = originalSpeed / newSpeed;
                        particle.vx *= scale;
                        particle.vy *= scale;
                    }



                    // å†æ›´æ–°ä½ç½®ï¼ˆä½¿ç”¨æ–°é€Ÿåº¦ï¼‰
                    particle.x += particle.vx * dt;
                    particle.y += particle.vy * dt;

                    // æ·»åŠ è½¨è¿¹ç‚¹
                    particle.trail.push({ x: particle.x, y: particle.y, time: Date.now() });

                    // é™åˆ¶è½¨è¿¹é•¿åº¦
                    if (particle.trail.length > 1000) {
                        particle.trail.shift();
                    }

                    // è¾¹ç•Œæ£€æµ‹ - å¼¹æ€§ç¢°æ’
                    const bounceFactor = 0.9;
                    if (particle.x < 0) {
                        particle.vx *= -bounceFactor;
                        particle.x = 0;
                    } else if (particle.x > this.canvas.width) {
                        particle.vx *= -bounceFactor;
                        particle.x = this.canvas.width;
                    }

                    if (particle.y < 0) {
                        particle.vy *= -bounceFactor;
                        particle.y = 0;
                    } else if (particle.y > this.canvas.height) {
                        particle.vy *= -bounceFactor;
                        particle.y = this.canvas.height;
                    }
                }
            }

            draw() {
                // åˆ›å»ºæ¸å˜èƒŒæ™¯æ•ˆæœ
                const gradient = this.ctx.createRadialGradient(
                    this.canvas.width / 2, this.canvas.height / 2, 0,
                    this.canvas.width / 2, this.canvas.height / 2, Math.max(this.canvas.width, this.canvas.height)
                );
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0.02)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.05)');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // ç»˜åˆ¶ç½‘æ ¼
                this.drawGrid();

                // ç»˜åˆ¶åæ ‡ç³»
                if (this.showCoordinateSystem) {
                    this.drawCoordinateSystem();
                }

                // ç»˜åˆ¶åœº
                this.drawFields();

                // ç»˜åˆ¶é‡åŠ›åœº
                this.drawGravityField();

                // ç»˜åˆ¶è½¨è¿¹
                this.drawTrails();

                // ç»˜åˆ¶ç²’å­
                this.drawParticles();
            }

            drawGrid() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
                this.ctx.lineWidth = 1;

                const gridSize = 50;

                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }

                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }

            drawCoordinateSystem() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;

                // è®¾ç½®åæ ‡ç³»æ ·å¼
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.lineWidth = 2;
                this.ctx.font = '14px Arial';
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                this.ctx.textAlign = 'center';

                // ç»˜åˆ¶Xè½´
                this.ctx.beginPath();
                this.ctx.moveTo(50, centerY);
                this.ctx.lineTo(this.canvas.width - 50, centerY);
                this.ctx.stroke();

                // ç»˜åˆ¶Yè½´
                this.ctx.beginPath();
                this.ctx.moveTo(centerX, 50);
                this.ctx.lineTo(centerX, this.canvas.height - 50);
                this.ctx.stroke();

                // ç»˜åˆ¶Xè½´ç®­å¤´
                this.ctx.beginPath();
                this.ctx.moveTo(this.canvas.width - 50, centerY);
                this.ctx.lineTo(this.canvas.width - 60, centerY - 5);
                this.ctx.moveTo(this.canvas.width - 50, centerY);
                this.ctx.lineTo(this.canvas.width - 60, centerY + 5);
                this.ctx.stroke();

                // ç»˜åˆ¶Yè½´ç®­å¤´
                this.ctx.beginPath();
                this.ctx.moveTo(centerX, 50);
                this.ctx.lineTo(centerX - 5, 60);
                this.ctx.moveTo(centerX, 50);
                this.ctx.lineTo(centerX + 5, 60);
                this.ctx.stroke();

                // ç»˜åˆ¶åæ ‡è½´æ ‡ç­¾
                this.ctx.fillText('X', this.canvas.width - 30, centerY - 10);
                this.ctx.fillText('Y', centerX + 10, 30);
                this.ctx.fillText('O', centerX - 15, centerY + 20);

                // ç»˜åˆ¶åˆ»åº¦çº¿
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                this.ctx.lineWidth = 1;

                const tickSpacing = 50;
                const tickLength = 8;

                // Xè½´åˆ»åº¦
                for (let x = centerX + tickSpacing; x < this.canvas.width - 50; x += tickSpacing) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, centerY - tickLength / 2);
                    this.ctx.lineTo(x, centerY + tickLength / 2);
                    this.ctx.stroke();

                    // åˆ»åº¦æ ‡ç­¾
                    const value = Math.round((x - centerX) / tickSpacing);
                    this.ctx.fillText(value.toString(), x, centerY + 20);
                }

                for (let x = centerX - tickSpacing; x > 50; x -= tickSpacing) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, centerY - tickLength / 2);
                    this.ctx.lineTo(x, centerY + tickLength / 2);
                    this.ctx.stroke();

                    // åˆ»åº¦æ ‡ç­¾
                    const value = Math.round((x - centerX) / tickSpacing);
                    this.ctx.fillText(value.toString(), x, centerY + 20);
                }

                // Yè½´åˆ»åº¦
                for (let y = centerY + tickSpacing; y < this.canvas.height - 50; y += tickSpacing) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX - tickLength / 2, y);
                    this.ctx.lineTo(centerX + tickLength / 2, y);
                    this.ctx.stroke();

                    // åˆ»åº¦æ ‡ç­¾
                    const value = Math.round((centerY - y) / tickSpacing);
                    this.ctx.fillText(value.toString(), centerX - 20, y + 5);
                }

                for (let y = centerY - tickSpacing; y > 50; y -= tickSpacing) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX - tickLength / 2, y);
                    this.ctx.lineTo(centerX + tickLength / 2, y);
                    this.ctx.stroke();

                    // åˆ»åº¦æ ‡ç­¾
                    const value = Math.round((centerY - y) / tickSpacing);
                    this.ctx.fillText(value.toString(), centerX - 20, y + 5);
                }
            }

            drawFields() {
                for (const field of this.fields) {
                    const alpha = Math.abs(field.strength) / 100 * 0.4;

                    if (field.type === 'electric') {
                        const color = field.strength > 0 ? '#ff6b6b' : '#4ecdc4';
                        this.ctx.fillStyle = color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                        this.drawFieldShape(field);

                        // ç»˜åˆ¶ç”µåœºçº¿æ–¹å‘
                        this.drawFieldArrows(field, color);
                    } else if (field.type === 'magnetic') {
                        const color = field.strength > 0 ? '#6b73ff' : '#ff6b9d';
                        this.ctx.fillStyle = color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                        this.drawFieldShape(field);

                        // ç»˜åˆ¶ç£åœºç¬¦å·
                        this.drawMagneticFieldSymbol(field, color);
                    }

                    // ç»˜åˆ¶è¾¹æ¡†
                    this.ctx.strokeStyle = field.strength > 0 ?
                        (field.type === 'electric' ? '#ff6b6b' : '#6b73ff') :
                        (field.type === 'electric' ? '#4ecdc4' : '#ff6b9d');
                    this.ctx.lineWidth = 2;
                    this.drawFieldBorder(field);
                }
            }

            drawFieldShape(field) {
                this.ctx.beginPath();

                switch (field.shape) {
                    case 'rectangle':
                        this.ctx.fillRect(field.x, field.y, field.endX - field.x, field.endY - field.y);
                        break;

                    case 'circle':
                        const radius = Math.min(field.width, field.height) / 2;
                        this.ctx.arc(field.centerX, field.centerY, radius, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;

                    case 'triangle':
                        this.ctx.moveTo(field.centerX, field.centerY - field.height / 2); // é¡¶ç‚¹
                        this.ctx.lineTo(field.centerX - field.width / 2, field.centerY + field.height / 2); // å·¦ä¸‹
                        this.ctx.lineTo(field.centerX + field.width / 2, field.centerY + field.height / 2); // å³ä¸‹
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;

                    case 'semicircle':
                        const semicircleRadius = Math.min(field.width, field.height) / 2;
                        this.ctx.arc(field.centerX, field.centerY, semicircleRadius, Math.PI, 0);
                        this.ctx.lineTo(field.centerX + semicircleRadius, field.centerY);
                        this.ctx.lineTo(field.centerX - semicircleRadius, field.centerY);
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;

                    case 'svg':
                        // ç®€åŒ–çš„SVGç»˜åˆ¶
                        this.ctx.fillRect(field.x, field.y, field.endX - field.x, field.endY - field.y);
                        break;

                    default:
                        this.ctx.fillRect(field.x, field.y, field.endX - field.x, field.endY - field.y);
                }
            }

            drawFieldBorder(field) {
                this.ctx.beginPath();

                switch (field.shape) {
                    case 'rectangle':
                        this.ctx.strokeRect(field.x, field.y, field.endX - field.x, field.endY - field.y);
                        break;

                    case 'circle':
                        const radius = Math.min(field.width, field.height) / 2;
                        this.ctx.arc(field.centerX, field.centerY, radius, 0, Math.PI * 2);
                        this.ctx.stroke();
                        break;

                    case 'triangle':
                        this.ctx.moveTo(field.centerX, field.centerY - field.height / 2);
                        this.ctx.lineTo(field.centerX - field.width / 2, field.centerY + field.height / 2);
                        this.ctx.lineTo(field.centerX + field.width / 2, field.centerY + field.height / 2);
                        this.ctx.closePath();
                        this.ctx.stroke();
                        break;

                    case 'semicircle':
                        const semicircleRadius = Math.min(field.width, field.height) / 2;
                        this.ctx.arc(field.centerX, field.centerY, semicircleRadius, Math.PI, 0);
                        this.ctx.lineTo(field.centerX + semicircleRadius, field.centerY);
                        this.ctx.lineTo(field.centerX - semicircleRadius, field.centerY);
                        this.ctx.closePath();
                        this.ctx.stroke();
                        break;

                    case 'svg':
                        this.ctx.strokeRect(field.x, field.y, field.endX - field.x, field.endY - field.y);
                        break;

                    default:
                        this.ctx.strokeRect(field.x, field.y, field.endX - field.x, field.endY - field.y);
                }
            }

            drawFieldArrows(field, color) {
                this.ctx.fillStyle = color;
                const arrowSpacing = 40;
                const centerX = (field.x + field.endX) / 2;
                const centerY = (field.y + field.endY) / 2;

                // ç»˜åˆ¶ç®­å¤´è¡¨ç¤ºæ–¹å‘
                this.ctx.beginPath();
                const arrowSize = 12;
                this.ctx.moveTo(centerX - arrowSize * field.direction.x, centerY - arrowSize * field.direction.y);
                this.ctx.lineTo(centerX + arrowSize * field.direction.x, centerY + arrowSize * field.direction.y);

                // ç»˜åˆ¶ç®­å¤´å¤´éƒ¨
                const headSize = 6;
                this.ctx.moveTo(centerX + arrowSize * field.direction.x, centerY + arrowSize * field.direction.y);
                this.ctx.lineTo(
                    centerX + (arrowSize - headSize) * field.direction.x - headSize * field.direction.y,
                    centerY + (arrowSize - headSize) * field.direction.y + headSize * field.direction.x
                );
                this.ctx.moveTo(centerX + arrowSize * field.direction.x, centerY + arrowSize * field.direction.y);
                this.ctx.lineTo(
                    centerX + (arrowSize - headSize) * field.direction.x + headSize * field.direction.y,
                    centerY + (arrowSize - headSize) * field.direction.y - headSize * field.direction.x
                );
                this.ctx.stroke();
            }

            drawMagneticFieldSymbol(field, color) {
                this.ctx.strokeStyle = color;
                this.ctx.fillStyle = color;
                this.ctx.lineWidth = 3;

                const centerX = (field.x + field.endX) / 2;
                const centerY = (field.y + field.endY) / 2;
                const radius = Math.min(field.endX - field.x, field.endY - field.y) / 6;

                // ç»˜åˆ¶åœ†å½¢
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                this.ctx.stroke();

                // æ ¹æ®ç£åœºæ–¹å‘ç»˜åˆ¶ç¬¦å·
                if (field.magneticDirection === 'out') {
                    // ç©¿å‡ºå±å¹• - ç»˜åˆ¶ç‚¹
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, radius * 0.3, 0, Math.PI * 2);
                    this.ctx.fill();

                    // ç»˜åˆ¶ç®­å¤´
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX - radius * 0.7, centerY);
                    this.ctx.lineTo(centerX + radius * 0.7, centerY);
                    this.ctx.moveTo(centerX + radius * 0.5, centerY - radius * 0.2);
                    this.ctx.lineTo(centerX + radius * 0.7, centerY);
                    this.ctx.lineTo(centerX + radius * 0.5, centerY + radius * 0.2);
                    this.ctx.stroke();
                } else {
                    // è¿›å…¥å±å¹• - ç»˜åˆ¶X
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX - radius * 0.5, centerY - radius * 0.5);
                    this.ctx.lineTo(centerX + radius * 0.5, centerY + radius * 0.5);
                    this.ctx.moveTo(centerX + radius * 0.5, centerY - radius * 0.5);
                    this.ctx.lineTo(centerX - radius * 0.5, centerY + radius * 0.5);
                    this.ctx.stroke();

                    // ç»˜åˆ¶ç®­å¤´
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX - radius * 0.7, centerY);
                    this.ctx.lineTo(centerX + radius * 0.7, centerY);
                    this.ctx.moveTo(centerX - radius * 0.5, centerY - radius * 0.2);
                    this.ctx.lineTo(centerX - radius * 0.7, centerY);
                    this.ctx.lineTo(centerX - radius * 0.5, centerY + radius * 0.2);
                    this.ctx.stroke();
                }
            }

            drawGravityField() {
                const gravityStrength = parseFloat(document.getElementById('gravityStrength').value);
                if (gravityStrength <= 0) return;

                this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
                this.ctx.lineWidth = 2;

                // ç»˜åˆ¶é‡åŠ›åœºçº¿
                const spacing = 80;
                const arrowSize = 15;

                for (let x = spacing; x < this.canvas.width; x += spacing) {
                    for (let y = spacing; y < this.canvas.height; y += spacing) {
                        // ç»˜åˆ¶é‡åŠ›æ–¹å‘ç®­å¤´
                        const endX = x + this.currentGravityDirection.x * arrowSize;
                        const endY = y + this.currentGravityDirection.y * arrowSize;

                        this.ctx.beginPath();
                        this.ctx.moveTo(x, y);
                        this.ctx.lineTo(endX, endY);

                        // ç»˜åˆ¶ç®­å¤´å¤´éƒ¨
                        const headSize = 6;
                        this.ctx.moveTo(endX, endY);
                        this.ctx.lineTo(
                            endX - headSize * this.currentGravityDirection.x - headSize * this.currentGravityDirection.y,
                            endY - headSize * this.currentGravityDirection.y + headSize * this.currentGravityDirection.x
                        );
                        this.ctx.moveTo(endX, endY);
                        this.ctx.lineTo(
                            endX - headSize * this.currentGravityDirection.x + headSize * this.currentGravityDirection.y,
                            endY - headSize * this.currentGravityDirection.y - headSize * this.currentGravityDirection.x
                        );
                        this.ctx.stroke();
                    }
                }
            }

            drawTrails() {
                for (const particle of this.particles) {
                    if (particle.trail.length < 2) continue;

                    this.ctx.lineWidth = 3;
                    this.ctx.lineCap = 'round';

                    for (let i = 1; i < particle.trail.length; i++) {
                        const point1 = particle.trail[i - 1];
                        const point2 = particle.trail[i];

                        // å½©è™¹é¢œè‰²æ¸å˜
                        const alpha = Math.min(1, i / particle.trail.length * 2);
                        const hue = (alpha * 360 + Date.now() * 0.2) % 360;

                        this.ctx.strokeStyle = `hsla(${hue}, 100%, 70%, ${alpha})`;

                        this.ctx.beginPath();
                        this.ctx.moveTo(point1.x, point1.y);
                        this.ctx.lineTo(point2.x, point2.y);
                        this.ctx.stroke();
                    }
                }
            }

            drawParticles() {
                for (const particle of this.particles) {
                    // ç»˜åˆ¶ç²’å­
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, 6, 0, Math.PI * 2);
                    this.ctx.fill();

                    // ç»˜åˆ¶ç²’å­å…‰æ™•
                    const gradient = this.ctx.createRadialGradient(
                        particle.x, particle.y, 0,
                        particle.x, particle.y, 12
                    );
                    gradient.addColorStop(0, particle.color + '80');
                    gradient.addColorStop(1, particle.color + '00');
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, 12, 0, Math.PI * 2);
                    this.ctx.fill();

                    // ç»˜åˆ¶ç”µè·ç¬¦å·
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = 'bold 14px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';

                    const chargeSymbol = particle.charge > 0 ? '+' : particle.charge < 0 ? '-' : '0';
                    this.ctx.fillText(chargeSymbol, particle.x, particle.y);

                    // ç»˜åˆ¶é€Ÿåº¦å‘é‡
                    if (this.isRunning) {
                        const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
                        if (speed > 0.5) {
                            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                            this.ctx.lineWidth = 2;
                            this.ctx.beginPath();
                            this.ctx.moveTo(particle.x, particle.y);
                            this.ctx.lineTo(
                                particle.x + particle.vx * 8,
                                particle.y + particle.vy * 8
                            );
                            this.ctx.stroke();
                        }
                    }
                }
            }

            startAnimation() {
                const animate = (currentTime) => {
                    const deltaTime = currentTime - this.lastTime;
                    this.lastTime = currentTime;

                    this.updateParticles(deltaTime);
                    this.draw();

                    this.animationId = requestAnimationFrame(animate);
                };

                this.animationId = requestAnimationFrame(animate);
            }
        }

        // å…¨å±€åæ ‡ç³»åˆ‡æ¢å‡½æ•°
        let simulationInstance = null;

        function toggleCoordinateSystem() {
            if (simulationInstance) {
                simulationInstance.showCoordinateSystem = !simulationInstance.showCoordinateSystem;
                const button = document.getElementById('coordinateButton');
                button.classList.toggle('active', simulationInstance.showCoordinateSystem);
            }
        }

        // å¯åŠ¨æ¨¡æ‹Ÿå™¨
        window.addEventListener('load', () => {
            simulationInstance = new ElectromagneticSimulation();
        });

        // å…¨å±€å‡½æ•°æ¥å£ - ä¾›ç”¨æˆ·é€šè¿‡å‡½æ•°æ–¹å¼æ“ä½œæ¨¡æ‹Ÿå™¨

        /**
         * åˆ›å»ºç”µåœº
         * @param {number} x1 - èµ·å§‹ç‚¹xåæ ‡
         * @param {number} y1 - èµ·å§‹ç‚¹yåæ ‡
         * @param {number} x2 - ç»“æŸç‚¹xåæ ‡
         * @param {number} y2 - ç»“æŸç‚¹yåæ ‡
         * @param {number} strength - åœºå¼ºåº¦ï¼Œé»˜è®¤50
         * @param {string} shape - åœºå½¢çŠ¶ï¼Œå¯é€‰ 'rectangle', 'circle', 'triangle', 'semicircle'ï¼Œé»˜è®¤ 'rectangle'
         * @param {string} direction - åœºæ–¹å‘ï¼Œå¯é€‰ 'right', 'left', 'up', 'down'ï¼Œé»˜è®¤ 'down'
         */
        function createE(x1, y1, x2, y2, strength = 50, shape = 'rectangle', direction = 'down') {
            if (!simulationInstance) return;
            
            // ä¿å­˜å½“å‰æ¨¡å¼
            const originalMode = simulationInstance.mode;
            
            // è®¾ç½®ä¸ºç”µåœºæ¨¡å¼å¹¶åˆ›å»ºåœº
            simulationInstance.mode = 'electric';
            simulationInstance.currentShape = shape;
            simulationInstance.currentFieldDirection = simulationInstance.getDirectionVector(direction);
            
            // ä¸´æ—¶è®¾ç½®åœºå¼ºåº¦
            document.getElementById('fieldStrength').value = strength;
            
            // åˆ›å»ºç”µåœº
            simulationInstance.createField({ x: x1, y: y1 }, { x: x2, y: y2 });
            
            // æ¢å¤åŸå§‹æ¨¡å¼
            simulationInstance.mode = originalMode;
        }

        /**
         * åˆ›å»ºç£åœº
         * @param {number} x1 - èµ·å§‹ç‚¹xåæ ‡
         * @param {number} y1 - èµ·å§‹ç‚¹yåæ ‡
         * @param {number} x2 - ç»“æŸç‚¹xåæ ‡
         * @param {number} y2 - ç»“æŸç‚¹yåæ ‡
         * @param {number} strength - åœºå¼ºåº¦ï¼Œé»˜è®¤50
         * @param {string} shape - åœºå½¢çŠ¶ï¼Œå¯é€‰ 'rectangle', 'circle', 'triangle', 'semicircle'ï¼Œé»˜è®¤ 'rectangle'
         * @param {string} magneticDirection - ç£åœºæ–¹å‘ï¼Œå¯é€‰ 'out'ï¼ˆç©¿å‡ºå±å¹•ï¼‰, 'in'ï¼ˆè¿›å…¥å±å¹•ï¼‰ï¼Œé»˜è®¤ 'out'
         */
        function createB(x1, y1, x2, y2, strength = 50, shape = 'rectangle', magneticDirection = 'out') {
            if (!simulationInstance) return;
            
            // ä¿å­˜å½“å‰æ¨¡å¼
            const originalMode = simulationInstance.mode;
            
            // è®¾ç½®ä¸ºç£åœºæ¨¡å¼å¹¶åˆ›å»ºåœº
            simulationInstance.mode = 'magnetic';
            simulationInstance.currentShape = shape;
            simulationInstance.currentMagneticDirection = magneticDirection;
            
            // ä¸´æ—¶è®¾ç½®åœºå¼ºåº¦
            document.getElementById('fieldStrength').value = strength;
            
            // åˆ›å»ºç£åœº
            simulationInstance.createField({ x: x1, y: y1 }, { x: x2, y: y2 });
            
            // æ¢å¤åŸå§‹æ¨¡å¼
            simulationInstance.mode = originalMode;
        }

        /**
         * åˆ›å»ºç”µè·ç²’å­
         * @param {number} x - ç²’å­xåæ ‡
         * @param {number} y - ç²’å­yåæ ‡
         * @param {number} mass - ç²’å­è´¨é‡ï¼Œé»˜è®¤1
         * @param {number} charge - ç”µè·é‡ï¼Œé»˜è®¤1
         * @param {number} speed - åˆé€Ÿåº¦å¤§å°ï¼Œé»˜è®¤0
         * @param {number} angle - é€Ÿåº¦è§’åº¦ï¼ˆåº¦ï¼‰ï¼Œé»˜è®¤90
         */
        function createParticle(x, y, mass = 1, charge = 1, speed = 0, angle = 90) {
            if (!simulationInstance) return;
            
            // å°†è§’åº¦è½¬æ¢ä¸ºå¼§åº¦
            const radians = angle * Math.PI / 180;
            // è®¡ç®—é€Ÿåº¦åˆ†é‡
            const vx = speed * Math.sin(radians);
            const vy = speed * Math.cos(radians);
            
            // åˆ›å»ºç²’å­
            simulationInstance.createParticle(x, y, mass, charge, vx, vy);
        }

        /**
         * å¼€å§‹æ¨¡æ‹Ÿ
         */
        function start() {
            if (simulationInstance) {
                simulationInstance.startSimulation();
            }
        }

        /**
         * æš‚åœæ¨¡æ‹Ÿ
         */
        function pause() {
            if (simulationInstance) {
                simulationInstance.pauseSimulation();
            }
        }

        /**
         * é‡ç½®æ¨¡æ‹Ÿ
         */
        function reset() {
            if (simulationInstance) {
                simulationInstance.resetSimulation();
            }
        }

        /**
         * è®¾ç½®é‡åŠ›åœº
         * @param {number} strength - é‡åŠ›å¼ºåº¦ï¼Œé»˜è®¤0
         * @param {string} direction - é‡åŠ›æ–¹å‘ï¼Œå¯é€‰ 'right', 'left', 'up', 'down'ï¼Œé»˜è®¤ 'down'
         */
        function setGravity(strength = 0, direction = 'down') {
            if (!simulationInstance) return;
            
            // è®¾ç½®é‡åŠ›å¼ºåº¦
            document.getElementById('gravityStrength').value = strength;
            document.getElementById('gravityValue').textContent = strength;
            
            // è®¾ç½®é‡åŠ›æ–¹å‘
            simulationInstance.currentGravityDirection = simulationInstance.getDirectionVector(direction);
        }

        /**
         * æ¸…é™¤æ‰€æœ‰åœº
         */
        function clearFields() {
            if (simulationInstance) {
                simulationInstance.fields = [];
            }
        }

        /**
         * æ¸…é™¤æ‰€æœ‰ç²’å­
         */
        function clearParticles() {
            if (simulationInstance) {
                simulationInstance.particles = [];
                simulationInstance.trails = [];
            }
        }


        createE(200, 200, 400, 300, 60, 'rectangle', 'right');

// åˆ›å»ºä¸€ä¸ªç©¿å‡ºå±å¹•çš„ç£åœºåŒºåŸŸ
createB(500, 200, 700, 400, 50, 'circle', 'out');

// åˆ›å»ºä¸€ä¸ªå¸¦æ­£ç”µçš„ç²’å­ï¼Œæœ‰ä¸€å®šåˆé€Ÿåº¦
createParticle(100, 250, 1, 1, 20, 0);

// è®¾ç½®é‡åŠ›åœº
setGravity(10, 'down');

// å¼€å§‹æ¨¡æ‹Ÿ
start();
    </script>
</body>

</html>
