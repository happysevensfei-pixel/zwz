<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matter.js示例</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            background-color: black;
            overflow: hidden;
            /* 禁止滚动条 */
            height: 100%;
            /* 确保 body 占满整个视口高度 */
        }

        #fullscreenButton {
            color: white;
            position: absolute;
            top: 10px;
            left: 10px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            font-size: 20px;
        }

        /* 右下角按钮容器 */
        #function-buttons {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 1000;
        }

        /* 通用按钮样式 */
        .fab-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            background: rgba(0, 0, 0, 0.3);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        /* 使用Material Icons字体的图标样式 */
        .material-icons {
            font-family: 'Material Icons';
            color: white;
            font-size: 20px;
        }

        /* 悬停效果 */
        .fab-button:hover {
            transform: scale(1.1);
            background: rgba(0, 0, 0, 0.5);
        }

        /* 悬浮窗样式 - 轻巧炫酷版 */
        .floating-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            width: 280px;
            min-height: 120px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(20, 20, 20, 0.8));
            backdrop-filter: blur(25px) saturate(1.5);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow:
                0 20px 40px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            padding: 16px;
            z-index: 2000;
            display: none;
            flex-direction: column;
            gap: 8px;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .floating-window.show {
            display: flex;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        /* 悬浮窗标题 - 更简洁 */
        .floating-window-title {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: linear-gradient(45deg, #fff, #aaa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* 悬浮窗按钮容器 - 网格布局 */
        .floating-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        /* 悬浮窗内按钮样式 - 更紧凑炫酷 */
        .floating-button {
            width: 100%;
            height: 36px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 12px;
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }

        .floating-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .floating-button:hover::before {
            left: 100%;
        }

        .floating-button:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px) scale(1.02);
            box-shadow:
                0 8px 20px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.1);
        }

        .floating-button:active {
            transform: translateY(0) scale(0.98);
        }

        .floating-button .button-icon {
            font-size: 16px;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
        }

        /* 关闭按钮 - 更炫酷 */
        .close-button {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
        }

        .close-button:hover {
            background: linear-gradient(135deg, rgba(255, 100, 100, 0.3), rgba(255, 50, 50, 0.2));
            border-color: rgba(255, 100, 100, 0.3);
            color: rgba(255, 255, 255, 1);
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 4px 12px rgba(255, 100, 100, 0.3);
        }

        /* 工具按钮激活状态 */
        .fab-button.active {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        /* 拖拽相关样式 */
        .floating-window.dragging {
            cursor: move;
            user-select: none;
            transition: none;
        }

        .floating-window.dragging * {
            pointer-events: none;
        }

        .floating-window.dragging .close-button {
            pointer-events: auto;
        }

        .floating-window .drag-handle {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 30px;
            cursor: move;
            z-index: 10;
            border-radius: 16px 16px 0 0;
        }

        .floating-window .drag-handle:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        /* 拖拽时的视觉反馈 */
        .floating-window.dragging {
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow:
                0 25px 50px rgba(0, 0, 0, 0.5),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        /* AI面板样式 - 黑白毛玻璃 */
        .ai-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: 450px;
            min-height: 300px;
            background: linear-gradient(135deg,
                    rgba(0, 0, 0, 0.95),
                    rgba(20, 20, 20, 0.9),
                    rgba(0, 0, 0, 0.95));
            backdrop-filter: blur(30px) saturate(1.2);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow:
                0 25px 50px rgba(0, 0, 0, 0.6),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            padding: 20px;
            z-index: 2000;
            display: none;
            flex-direction: column;
            gap: 15px;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .ai-panel.show {
            display: flex;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        .ai-panel.dragging {
            cursor: move;
            user-select: none;
            transition: none;
        }

        .ai-panel.dragging * {
            pointer-events: none;
        }

        .ai-panel.dragging .close-button {
            pointer-events: auto;
        }

        /* AI面板标题 */
        .ai-panel-title {
            color: #ffffff;
            font-size: 18px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
            position: relative;
        }

        .ai-panel-title::before {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 2px;
            background: linear-gradient(90deg, transparent, #ffffff, transparent);
        }

        /* AI选择区域 */
        .ai-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .ai-option {
            flex: 1;
            padding: 12px 16px;
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.1),
                    rgba(255, 255, 255, 0.05));
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            color: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-weight: 600;
            position: relative;
            overflow: hidden;
        }

        .ai-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .ai-option:hover::before {
            left: 100%;
        }

        .ai-option:hover {
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.2),
                    rgba(255, 255, 255, 0.1));
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(255, 255, 255, 0.2);
        }

        .ai-option.active {
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.3),
                    rgba(255, 255, 255, 0.15));
            border-color: #ffffff;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
        }

        /* 对话框区域 */
        .ai-chat-area {
            flex: 1;
            min-height: 200px;
            background: linear-gradient(135deg,
                    rgba(0, 0, 0, 0.8),
                    rgba(20, 20, 20, 0.6));
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 15px;
            overflow-y: auto;
            /* 确保垂直滚动 */
            position: relative;
            max-height: 300px;
            /* 设置最大高度 */
            scrollbar-width: thin;
            /* Firefox */
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
            /* Firefox */
        }

        /* 自定义滚动条样式 */
        .ai-chat-area::-webkit-scrollbar {
            width: 6px;
        }

        .ai-chat-area::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        .ai-chat-area::-webkit-scrollbar-track {
            background: transparent;
        }


        .ai-chat-area::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
            pointer-events: none;
        }

        .ai-message {
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 10px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border-left: 3px solid #ffffff;
            font-size: 14px;
            line-height: 1.4;
        }

        .ai-message.user {
            background: rgba(255, 255, 255, 0.1);
            border-left-color: #ffffff;
            margin-left: 20px;
        }

        .ai-message.ai {
            background: rgba(0, 255, 255, 0.1);
            border-left-color: #00ffff;
            margin-right: 20px;
        }

        /* 输入区域 */
        .ai-input-area {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .ai-input {
            flex: 1;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 25px;
            color: #ffffff;
            font-size: 14px;
            outline: none;
            transition: all 0.3s ease;
        }

        .ai-input:focus {
            border-color: #ffffff;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        .ai-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        /* 功能按钮区域 */
        .ai-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .ai-action-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.2),
                    rgba(255, 255, 255, 0.1));
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 20px;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .ai-action-btn:hover {
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.3),
                    rgba(255, 255, 255, 0.2));
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(255, 255, 255, 0.3);
        }

        /* AI面板拖拽手柄 */
        .ai-panel .drag-handle {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            cursor: move;
            z-index: 10;
            border-radius: 20px 20px 0 0;
        }

        .ai-panel .drag-handle:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        /* AI面板关闭按钮 */
        .ai-panel .close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(255, 100, 100, 0.2), rgba(255, 50, 50, 0.1));
            border: 1px solid rgba(255, 100, 100, 0.3);
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
        }

        .ai-panel .close-button:hover {
            background: linear-gradient(135deg, rgba(255, 100, 100, 0.4), rgba(255, 50, 50, 0.3));
            border-color: rgba(255, 100, 100, 0.5);
            color: #ffffff;
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 4px 12px rgba(255, 100, 100, 0.4);
        }

        /* AI按钮激活状态 */
        .fab-button.ai-active {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
        }



        /* 对话警示框样式 */
        .alert-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: linear-gradient(135deg,
                    rgba(0, 0, 0, 0.95),
                    rgba(20, 20, 20, 0.9),
                    rgba(0, 0, 0, 0.95));
            backdrop-filter: blur(30px) saturate(1.2);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow:
                0 25px 50px rgba(0, 0, 0, 0.6),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            padding: 30px;
            z-index: 5000;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            min-width: 300px;
            max-width: 500px;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .alert-dialog.show {
            display: flex;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        .alert-dialog-icon {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.2),
                    rgba(255, 255, 255, 0.1));
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            color: #ffffff;
        }

        .alert-dialog-title {
            color: #ffffff;
            font-size: 20px;
            font-weight: 700;
            text-align: center;
            margin: 0;
        }

        .alert-dialog-message {
            color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            text-align: center;
            line-height: 1.5;
            margin: 0;
        }

        .alert-dialog-buttons {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }

        .alert-dialog-btn {
            padding: 12px 24px;
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.2),
                    rgba(255, 255, 255, 0.1));
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 25px;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 600;
            min-width: 80px;
        }

        .alert-dialog-btn:hover {
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.3),
                    rgba(255, 255, 255, 0.2));
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(255, 255, 255, 0.3);
        }

        .alert-dialog-btn.primary {
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.3),
                    rgba(255, 255, 255, 0.2));
            border-color: rgba(255, 255, 255, 0.6);
        }

        /* 底部按钮区域 */
        .bottom-toolbar {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 1000;
        }

        .bottom-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(20px);
            background: linear-gradient(135deg,
                    rgba(0, 0, 0, 0.8),
                    rgba(20, 20, 20, 0.6));
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .bottom-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .bottom-btn:hover::before {
            left: 100%;
        }

        .bottom-btn:hover {
            transform: scale(1.1);
            background: linear-gradient(135deg,
                    rgba(0, 0, 0, 0.9),
                    rgba(20, 20, 20, 0.7));
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
        }

        .bottom-btn.active {
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.3),
                    rgba(255, 255, 255, 0.2));
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .bottom-btn .material-icons {
            color: white;
            font-size: 24px;
            z-index: 1;
        }

        /* 笔工具面板 */
        .drawing-panel {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg,
                    rgba(0, 0, 0, 0.95),
                    rgba(20, 20, 20, 0.9),
                    rgba(0, 0, 0, 0.95));
            backdrop-filter: blur(30px) saturate(1.2);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.6);
            padding: 20px;
            z-index: 2000;
            display: none;
            flex-direction: column;
            gap: 15px;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .drawing-panel.show {
            display: flex;
            opacity: 1;
        }

        .drawing-tools {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .tool-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.1),
                    rgba(255, 255, 255, 0.05));
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .tool-btn:hover {
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.2),
                    rgba(255, 255, 255, 0.1));
            transform: scale(1.05);
        }

        .tool-btn.active {
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.3),
                    rgba(255, 255, 255, 0.2));
            border-color: rgba(255, 255, 255, 0.6);
        }

        .color-picker {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            background: #ff0000;
        }

        .brush-size {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
        }

        .brush-size input {
            width: 100px;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .brush-size input::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
        }

        /* 文件显示幕布 */
        .file-curtain {
            position: fixed;
            top: -100%;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg,
                    rgba(0, 0, 0, 0.95),
                    rgba(20, 20, 20, 0.9),
                    rgba(0, 0, 0, 0.95));
            backdrop-filter: blur(30px) saturate(1.2);
            z-index: 3000;
            display: none;
            flex-direction: column;
            transition: top 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .file-curtain.show {
            display: flex;
            top: 0;
        }

        .file-header {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-title {
            color: white;
            font-size: 18px;
            font-weight: 600;
        }

        .file-controls {
            display: flex;
            gap: 10px;
        }

        .file-control-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.1),
                    rgba(255, 255, 255, 0.05));
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .file-control-btn:hover {
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.2),
                    rgba(255, 255, 255, 0.1));
            transform: scale(1.05);
        }

        .file-content {
            flex: 1;
            padding: 20px;
            overflow: auto;
            position: relative;
        }

        .file-canvas {
            width: 100%;
            height: 100%;
            background: white;
            border-radius: 8px;
            position: relative;
            min-height: 400px;
        }

        /* 画布样式 */
        #drawingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            width: 100%;
            height: 100%;
        }



        /*侧边栏*/

        .content {
            flex: 1;
            margin-right: 50px;
        }

        .sidebar {
            width: 50px;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.9);
            /* 深色背景 */
            position: fixed;
            right: 0;
            top: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            /* 添加浅色边框 */
        }

        .sidebar-button {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.1);
            /* 半透明按钮 */
            color: rgba(255, 255, 255, 0.9);
            /* 白色文字 */
            top: 50%;
            cursor: pointer;
            position: absolute;
            right: 0;
            transform: translateX(0);
            transition: transform 0.5s ease;
            border: 3px solid rgba(255, 255, 255, 0.2);
            /* 添加边框 */
            z-index: 9999;
            background-image: url('/zwz/logo.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .sidebar-panel {
            width: 300px;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.85);
            /* 深色背景 */
            position: fixed;
            right: -300px;
            top: 0;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.3);
            /* 加深阴影 */
            border-top-left-radius: 10px;
            border-bottom-left-radius: 10px;
            transition: right 0.5s ease;
            display: flex;
            flex-direction: column;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            /* 添加边框 */
            z-index: 9999;
        }

        .sidebar-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0, 0, 0, 0.6);
            /* 内容区背景 */
        }

        .slanted-div {
            width: 100%;
            height: 200px;
            background-color: rgba(255, 255, 255, 0.1);
            /* 半透明白色 */
            margin: 5px 0;
        }

        .sidebar-panel-buttons {
            height: 50px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            /* 浅色分割线 */
        }

        .button {
            width: 100px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.1);
            /* 按钮背景 */
            color: rgba(255, 255, 255, 0.9);
            /* 白色文字 */
            border: 1px solid rgba(255, 255, 255, 0.2);
            /* 按钮边框 */
            border-radius: 5px;
            cursor: pointer;
        }

        .active .sidebar-panel {
            right: 0;
        }

        .active .sidebar-button {
            transform: translateX(-300px)
        }

        .active .content {
            margin-right: 350px;
        }

        /* 全局滚动条样式 */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
            background-color: rgba(0, 0, 0, 0.2);
        }

        ::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        ::-webkit-scrollbar-thumb:hover {
            background-color: rgba(255, 255, 255, 0.4);
        }

        ::-webkit-scrollbar-track {
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }

        /* 特定区域滚动条 */
        .sidebar-panel-content::-webkit-scrollbar,
        .file-content::-webkit-scrollbar {
            width: 6px;
        }

        .ai-chat-area::-webkit-scrollbar {
            width: 4px;
        }

        /*绳子*/
        /* 添加在样式表中 */
        .elastic-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            width: 320px;
            background: linear-gradient(135deg,
                    rgba(0, 0, 0, 0.95),
                    rgba(20, 20, 20, 0.9));
            backdrop-filter: blur(25px) saturate(1.5);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            padding: 16px;
            z-index: 3000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .elastic-dialog.show {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
        }

        .dialog-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .dialog-title {
            color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: linear-gradient(45deg, #fff, #aaa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .dialog-close-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .dialog-close-btn:hover {
            background: rgba(255, 100, 100, 0.3);
            transform: rotate(90deg);
        }

        .slider-container {
            padding: 12px 0;
        }

        .elastic-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            outline: none;
        }

        .elastic-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #ffffff;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .elastic-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .slider-value {
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            text-align: center;
            margin-top: 8px;
        }

        .dialog-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 16px;
        }

        .dialog-btn {
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.1),
                    rgba(255, 255, 255, 0.05));
            color: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .dialog-btn:hover {
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.2),
                    rgba(255, 255, 255, 0.1));
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .dialog-btn.confirm {
            background: linear-gradient(135deg,
                    rgba(0, 150, 255, 0.3),
                    rgba(0, 100, 200, 0.2));
            border-color: rgba(0, 150, 255, 0.3);
        }


        /* Canvas画板样式 */
        .canvas-container {
            position: fixed;
            top: -500px;
            width: 600px;
            height: 300px;
            background: linear-gradient(135deg,
                    rgba(0, 0, 0, 0.95),
                    rgba(20, 20, 20, 0.9),
                    rgba(0, 0, 0, 0.95));
            backdrop-filter: blur(30px) saturate(1.2);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow:
                0 25px 50px rgba(0, 0, 0, 0.6),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            z-index: 2500;
            display: flex;
            flex-direction: column;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-50px) scale(0.8);
            transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
            cursor: move;
            user-select: none;
        }

        .canvas-container.show {
            top: 100px;
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
        }

        .canvas-container.left {
            left: 50px;
        }

        .canvas-container.right {
            right: 50px;
        }

        .canvas-container.dragging {
            cursor: move;
            transition: none;
            z-index: 3000;
        }

        /* Canvas头部 */
        .canvas-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px 16px 0 0;
        }

        .canvas-title {
            color: #ffffff;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .canvas-close-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .canvas-close-btn:hover {
            background: rgba(255, 100, 100, 0.3);
            border-color: rgba(255, 100, 100, 0.3);
            color: #ffffff;
            transform: scale(1.1);
        }

        /* Canvas画布 */
        .physics-canvas {
            flex: 1;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 0 0 16px 16px;
            cursor: crosshair;
        }




        /* 在原有样式表中添加 */
        .param-item {
            margin: 15px 0;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .param-item label {
            color: rgba(255, 255, 255, 0.9);
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .time-input {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        .time-input input {
            width: 80px;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            color: white;
            font-size: 14px;
            margin-right: 8px;
        }

        .time-input span {
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
        }

        .param-group {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 8px;
        }

        /* 高级布局与数值标签 */
        .advanced-grid {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .section-title {
            color: #ffffff;
            font-size: 13px;
            letter-spacing: 2px;
            opacity: 0.8;
            margin: 8px 0 2px;
        }

        .param-row {
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 10px;
        }

        .row-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .row-header .left {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 120px;
        }

        .row-header .right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .row-slider {
            width: 100%;
        }

        .row-time {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .param-label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
        }

        /* 颜色选择器样式 */
        .color-picker {
            width: 40px;
            height: 24px;
            border: none;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
            outline: none;
            transition: all 0.2s ease;
        }

        .color-picker:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .param-control input[type=range] {
            width: 100%;
        }

        .param-value .value-chip {
            display: inline-block;
            min-width: 48px;
            text-align: center;
            padding: 4px 8px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #fff;
            font-size: 12px;
        }

        .param-time {
            display: flex;
            align-items: center;
            gap: 6px;
            justify-content: flex-end;
        }

        .param-time input[type=range] {
            width: 100%;
        }

        /* 更炫酷的滑块样式 */
        .elastic-slider {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 4px;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            outline: none;
        }

        .elastic-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
            transition: transform .15s ease;
        }

        .elastic-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        /* 递增/递减按钮 */
        .stepper {
            display: flex;
            gap: 6px;
            margin-left: 8px;
        }

        .step-btn {
            width: 24px;
            height: 24px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
            cursor: pointer;
            transition: transform .15s ease, background .15s ease;
        }

        .step-btn:hover {
            transform: scale(1.08);
            background: rgba(255, 255, 255, 0.15);
        }

        /* 预设快捷选项 */
        .preset-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin: 4px 0 6px;
        }

        .preset-chip {
            padding: 6px 10px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.25);
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            transition: transform .12s ease, background .12s ease;
        }

        .preset-chip:hover {
            transform: translateY(-1px);
            background: rgba(255, 255, 255, 0.14);
        }

        /* 自定义滚动条 */
        .param-group::-webkit-scrollbar {
            width: 6px;
        }

        .param-group::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        /* 悬浮球按钮 */
        .floating-ball {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 56px;
            height: 56px;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 3000;
            backdrop-filter: blur(20px);
            background: linear-gradient(135deg,
                    rgba(0, 0, 0, 0.9),
                    rgba(20, 20, 20, 0.7));
            border: 1px solid rgba(255, 255, 255, 0.25);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        }

        .floating-ball.show {
            display: flex;
        }

        .floating-ball:hover {
            transform: scale(1.08);
            background: linear-gradient(135deg,
                    rgba(0, 0, 0, 0.95),
                    rgba(20, 20, 20, 0.8));
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.55);
        }

        .floating-ball .material-icons {
            color: #ffffff;
            font-size: 24px;
        }

        .floating-ball-handle {
            position: fixed;
            top: 50%;
            left: calc(50% + 50px);
            transform: translate(-50%, -50%);
            width: 70px;
            height: 28px;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: move;
            z-index: 3001;
            border-radius: 16px;
            backdrop-filter: blur(18px);
            background: linear-gradient(135deg,
                    rgba(0, 0, 0, 0.75),
                    rgba(20, 20, 20, 0.6));
            border: 1px solid rgba(255, 255, 255, 0.22);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            color: rgba(255, 255, 255, 0.85);
            font-size: 12px;
            letter-spacing: 1px;
        }

        .floating-ball-handle.show {
            display: flex;
        }

        /* 禁止文本和图标被选中 */
        .floating-window-title,
        .floating-button,
        .floating-button * {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* 如果需要应用到整个界面 */
        body {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }


        /* 文件命名对话框样式 */
        #fileNameDialog {
            width: 320px;
            min-height: 180px;
        }

        #fileNameDialog .param-item {
            margin: 15px 0;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        #fileNameDialog .param-item label {
            color: rgba(255, 255, 255, 0.9);
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #fileNameDialog .dialog-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 16px;
        }

        #fileNameDialog .dialog-btn {
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.1),
                    rgba(255, 255, 255, 0.05));
            color: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #fileNameDialog .dialog-btn:hover {
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.2),
                    rgba(255, 255, 255, 0.1));
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        #fileNameDialog .dialog-btn.confirm {
            background: linear-gradient(135deg,
                    rgba(0, 150, 255, 0.3),
                    rgba(0, 100, 200, 0.2));
            border-color: rgba(0, 150, 255, 0.3);
        }

        /* 代码编辑器样式 */
        .code-editor-container {
            flex: 1;
            margin: 12px 0;
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }

        #codeEditor {
            width: 100%;
            height: 300px;
            padding: 12px;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.9);
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            resize: none;
            outline: none;
            tab-size: 4;
        }

        #codeEditor:focus {
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.2);
        }

        /* 弹性对话框样式 */
        #elasticDialog {
            width: 320px;
            min-height: 180px;
        }

        .slider-container {
            padding: 12px 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .slider-value {
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            text-align: center;
            margin-top: 8px;
        }

        .elastic-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 4px;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            outline: none;
        }

        .elastic-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
            transition: transform .15s ease;
        }

        .elastic-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
    </style>
</head>

<body>

    <!-- 需要先在<head>中添加Material Icons字体 -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <!-- 右下角功能按钮 -->
    <div id="function-buttons">
        <button class="fab-button" id="toolsButton">
            <span class="material-icons">build</span>
        </button>
        <button class="fab-button" id="aiButton">
            <span class="material-icons">psychology</span>
        </button>
        <button class="fab-button" id="downloadButton">
            <span class="material-icons">download</span>
        </button>
        <button class="fab-button" id="codeButton">
            <span class="material-icons">code</span>
        </button>

    </div>

    <!-- 悬浮窗 -->
    <div class="floating-window" id="floatingWindow">
        <div class="drag-handle" id="dragHandle"></div>
        <button class="close-button" id="closeButton"></button>
        <div class="floating-window-title">工具面板</div>
        <div class="floating-buttons" id="floatingButtons">
            <!-- 动态添加的按钮将在这里显示 -->
        </div>
    </div>

    <!-- AI面板 -->
    <div class="ai-panel" id="aiPanel">
        <div class="drag-handle" id="aiDragHandle"></div>
        <button class="close-button" id="aiCloseButton"></button>
        <div class="ai-panel-title">AI 助手</div>

        <!-- AI选择器 -->
        <div class="ai-selector">
            <div class="ai-option active" data-ai="niuxiaodun">
                <span class="material-icons">school</span>
                牛小顿
            </div>
            <div class="ai-option" data-ai="qiqiboshi">
                <span class="material-icons">science</span>
                七七博士
            </div>
        </div>

        <!-- 对话框区域 -->
        <div class="ai-chat-area" id="aiChatArea">
            <div class="ai-message ai">
                <strong>牛小顿：</strong>你好！我是牛小顿，你的学习助手。有什么问题可以问我哦！
            </div>
        </div>

        <!-- 输入区域 -->
        <div class="ai-input-area">
            <input type="text" class="ai-input" id="aiInput" placeholder="输入你的问题...">
            <button class="ai-action-btn" id="sendBtn">
                <span class="material-icons">send</span>
                发送
            </button>
        </div>

        <!-- 功能按钮区域 -->
        <div class="ai-actions">
            <button class="ai-action-btn" id="uploadBtn">
                <span class="material-icons">upload_file</span>
                上传题目
            </button>
            <button class="ai-action-btn" id="clearBtn">
                <span class="material-icons">clear_all</span>
                清空对话
            </button>
        </div>
    </div>


    <!-- 对话警示框 -->
    <div class="alert-dialog" id="alertDialog">
        <div class="alert-dialog-icon" id="alertIcon">⚠️</div>
        <h3 class="alert-dialog-title" id="alertTitle">提示</h3>
        <p class="alert-dialog-message" id="alertMessage">这是一个警示消息</p>
        <div class="alert-dialog-buttons" id="alertButtons">
            <button class="alert-dialog-btn primary" id="alertConfirm">确定</button>
        </div>
    </div>

    <!-- 底部工具栏 -->
    <div class="bottom-toolbar">
        <button class="bottom-btn" id="drawingBtn">
            <span class="material-icons">brush</span>
        </button>
        <button class="bottom-btn" id="playBtn">
            <span class="material-icons">play_arrow</span>
        </button>
        <button class="bottom-btn" id="importBtn">
            <span class="material-icons">upload_file</span>
        </button>
        <button class="bottom-btn" id="plotToggleBtn" title="速度-时间图像">
            <span class="material-icons">show_chart</span>
        </button>
        <button class="bottom-btn" id="fullscreenToggleBtn" title="全屏/退出全屏">
            <span class="material-icons">fullscreen</span>
        </button>
    </div>

    <!-- 笔工具面板 -->
    <div class="drawing-panel" id="drawingPanel">
        <div class="drawing-tools">
            <button class="tool-btn active" id="brushTool" data-tool="brush">
                <span class="material-icons">brush</span>
            </button>
            <button class="tool-btn" id="eraserTool" data-tool="eraser">
                <span class="material-icons">auto_fix_high</span>
            </button>
            <button class="tool-btn" id="lineTool" data-tool="line">
                <span class="material-icons">show_chart</span>
            </button>
            <button class="tool-btn" id="circleTool" data-tool="circle">
                <span class="material-icons">radio_button_unchecked</span>
            </button>
            <button class="tool-btn" id="rectTool" data-tool="rect">
                <span class="material-icons">crop_square</span>
            </button>
            <button class="tool-btn" id="physicsModeBtn" data-tool="physics" title="物理对象创建模式">
                <span class="material-icons">physics</span>
            </button>
            <input type="color" class="color-picker" id="colorPicker" value="#ff0000">
            <div class="brush-size">
                <span>大小:</span>
                <input type="range" id="brushSize" min="1" max="20" value="5">
            </div>
        </div>
    </div>

    <!-- 文件显示幕布 -->
    <div class="file-curtain" id="fileCurtain">
        <div class="file-header">
            <div class="file-title" id="fileTitle">文件预览</div>
            <div class="file-controls">
                <button class="file-control-btn" id="playPauseBtn">
                    <span class="material-icons">play_arrow</span>
                </button>
                <button class="file-control-btn" id="prevPageBtn">
                    <span class="material-icons">navigate_before</span>
                </button>
                <button class="file-control-btn" id="canvasToggleBtn" title="画板开关">
                    <span class="material-icons">dashboard</span>
                </button>
                <button class="file-control-btn" id="drawModeBtn">
                    <span class="material-icons">edit</span>
                </button>
                <button class="file-control-btn" id="closeFileBtn">
                    <span class="material-icons">close</span>
                </button>
            </div>
        </div>
        <div class="file-content">
            <div class="file-canvas" id="fileCanvas">
                <canvas id="drawingCanvas"></canvas>
            </div>
        </div>
    </div>


    <div class="sidebar-button" onclick="toggleSidebar()"></div>
    <!-- </div> -->
    <div class="sidebar-panel">
        <div class="sidebar-panel-content" id="sceneList">
            <!-- 初始为空 -->
        </div>
        <div class="sidebar-panel-buttons">
            <button class="button" id="btnNewScene">新建</button>
            <button class="button" id="btnAiArrange">AI整理</button>
        </div>
    </div>
    <!-- 在body末尾添加 -->
    <div class="elastic-dialog">
        <div class="dialog-header">
            <div class="dialog-title">选择绳子的弹性系数</div>
            <button class="dialog-close-btn">&times;</button>
        </div>
        <div class="dialog-content">
            <div class="slider-container">
                <input type="range" class="elastic-slider" min="0" max="1" step="0.01" value="0.5">
                <div class="slider-value">0.5</div>
            </div>
        </div>
        <div class="dialog-footer">
            <button class="dialog-btn cancel">取消</button>
            <button class="dialog-btn confirm">确定</button>
        </div>
    </div>
    <!-- Canvas画板 -->
    <div class="canvas-container left" id="leftCanvasContainer">
        <div class="canvas-header">
            <span class="canvas-title">水平速度-时间图像</span>
            <button class="canvas-close-btn" onclick="canvasPanelManager.hidePanels()">×</button>
        </div>
        <canvas id="leftCanvas" class="physics-canvas"></canvas>
    </div>

    <div class="canvas-container right" id="rightCanvasContainer">
        <div class="canvas-header">
            <span class="canvas-title">竖直速度-时间图像</span>
            <button class="canvas-close-btn" onclick="canvasPanelManager.hidePanels()">×</button>
        </div>
        <canvas id="rightCanvas" class="physics-canvas"></canvas>
    </div>

    <!-- 在body内添加面板HTML -->
    <div class="floating-window" id="speedForcePanel">
        <div class="drag-handle"></div>
        <button class="close-button" onclick="speedForcePanel.hide()">×</button>
        <div class="floating-window-title">动力参数设置</div>

        <div class="param-group advanced-grid">
            <div class="section-title">速度 Velocity</div>
            <div class="preset-row">
                <div class="preset-chip" data-target="horizontalSpeed" data-value="-10">vx -10</div>
                <div class="preset-chip" data-target="horizontalSpeed" data-value="0">vx 0</div>
                <div class="preset-chip" data-target="horizontalSpeed" data-value="10">vx 10</div>
                <div class="preset-chip" data-target="verticalSpeed" data-value="-10">vy -10</div>
                <div class="preset-chip" data-target="verticalSpeed" data-value="0">vy 0</div>
                <div class="preset-chip" data-target="verticalSpeed" data-value="10">vy 10</div>
            </div>
            <div class="param-row">
                <div class="row-header">
                    <div class="left">
                        <div class="param-label">水平 vx</div>
                    </div>
                    <div class="right">
                        <span class="value-chip" id="horizontalSpeedVal">0</span>
                        <div class="stepper">
                            <button class="step-btn" data-step="-1" data-target="horizontalSpeed">-</button>
                            <button class="step-btn" data-step="1" data-target="horizontalSpeed">+</button>
                        </div>
                    </div>
                </div>
                <div class="row-slider">
                    <input type="range" class="elastic-slider" id="horizontalSpeed" min="-40" max="40" value="0">
                </div>
                <div class="row-time">
                    <input type="range" id="hSpeedTime" min="0" max="50" value="1">
                    <span class="value-chip" id="hSpeedTimeVal">1</span><span class="unit"> 秒</span>
                </div>
            </div>

            <div class="param-row">
                <div class="row-header">
                    <div class="left">
                        <div class="param-label">竖直 vy</div>
                    </div>
                    <div class="right">
                        <span class="value-chip" id="verticalSpeedVal">0</span>
                        <div class="stepper">
                            <button class="step-btn" data-step="-1" data-target="verticalSpeed">-</button>
                            <button class="step-btn" data-step="1" data-target="verticalSpeed">+</button>
                        </div>
                    </div>
                </div>
                <div class="row-slider">
                    <input type="range" class="elastic-slider" id="verticalSpeed" min="-40" max="40" value="0">
                </div>
                <div class="row-time">
                    <input type="range" id="vSpeedTime" min="0" max="50" value="1">
                    <span class="value-chip" id="vSpeedTimeVal">1</span><span class="unit"> 秒</span>
                </div>
            </div>

            <div class="section-title">力 Force</div>
            <div class="preset-row">
                <div class="preset-chip" data-target="horizontalForce" data-value="-10">Fx -10</div>
                <div class="preset-chip" data-target="horizontalForce" data-value="0">Fx 0</div>
                <div class="preset-chip" data-target="horizontalForce" data-value="10">Fx 10</div>
                <div class="preset-chip" data-target="verticalForce" data-value="-10">Fy -10</div>
                <div class="preset-chip" data-target="verticalForce" data-value="0">Fy 0</div>
                <div class="preset-chip" data-target="verticalForce" data-value="10">Fy 10</div>
            </div>
            <div class="param-row">
                <div class="row-header">
                    <div class="left">
                        <div class="param-label">水平 Fx</div>
                    </div>
                    <div class="right">
                        <span class="value-chip" id="horizontalForceVal">0</span>
                        <div class="stepper">
                            <button class="step-btn" data-step="-1" data-target="horizontalForce">-</button>
                            <button class="step-btn" data-step="1" data-target="horizontalForce">+</button>
                        </div>
                    </div>
                </div>
                <div class="row-slider">
                    <input type="range" class="elastic-slider" id="horizontalForce" min="-40" max="40" value="0">
                </div>
                <div class="row-time">
                    <input type="range" id="hForceTime" min="0" max="50" value="1">
                    <span class="value-chip" id="hForceTimeVal">1</span><span class="unit"> 秒</span>
                </div>
            </div>

            <div class="param-row">
                <div class="row-header">
                    <div class="left">
                        <div class="param-label">竖直 Fy</div>
                    </div>
                    <div class="right">
                        <span class="value-chip" id="verticalForceVal">0</span>
                        <div class="stepper">
                            <button class="step-btn" data-step="-1" data-target="verticalForce">-</button>
                            <button class="step-btn" data-step="1" data-target="verticalForce">+</button>
                        </div>
                    </div>
                </div>
                <div class="row-slider">
                    <input type="range" class="elastic-slider" id="verticalForce" min="-40" max="40" value="0">
                </div>
                <div class="row-time">
                    <input type="range" id="vForceTime" min="0" max="50" value="1">
                    <span class="value-chip" id="vForceTimeVal">1</span><span class="unit"> 秒</span>
                </div>
            </div>
        </div>

        <div class="dialog-footer">
            <button class="dialog-btn confirm" onclick="speedForcePanel.confirm()">确定</button>
            <button class="dialog-btn cancel" onclick="speedForcePanel.hide()">取消</button>
        </div>
    </div>


    <!-- 世界属性设置面板 -->
    <div class="floating-window" id="worldSettingsPanel">
        <div class="drag-handle"></div>
        <button class="close-button" onclick="worldSettingsPanel.hide()"></button>
        <div class="floating-window-title">世界属性设置</div>

        <div class="param-group advanced-grid">
            <div class="section-title">物理环境 Physics</div>

            <div class="param-row">
                <div class="row-header">
                    <div class="left">
                        <div class="param-label">重力 Gravity</div>
                    </div>
                    <div class="right">
                        <span class="value-chip" id="gravityVal">1</span>
                        <div class="stepper">
                            <button class="step-btn" data-step="-0.1" data-target="gravity">-</button>
                            <button class="step-btn" data-step="0.1" data-target="gravity">+</button>
                        </div>
                    </div>
                </div>
                <div class="row-slider">
                    <input type="range" class="elastic-slider" id="gravity" min="-20" max="20" step="0.1" value="1" />
                </div>
            </div>

            <div class="param-row">
                <div class="row-header">
                    <div class="left">
                        <div class="param-label">水平场大小 Field Size</div>
                    </div>
                    <div class="right">
                        <span class="value-chip" id="fieldSizeVal">0</span>
                        <div class="stepper">
                            <button class="step-btn" data-step="-0.1" data-target="fieldSize">-</button>
                            <button class="step-btn" data-step="0.1" data-target="fieldSize">+</button>
                        </div>
                    </div>
                </div>
                <div class="row-slider">
                    <input type="range" class="elastic-slider" id="fieldSize" min="-20" max="20" step="0.1" value="0" />
                </div>
            </div>

            <div class="param-row">
                <div class="row-header">
                    <div class="left">
                        <div class="param-label">地面摩擦因数 Friction</div>
                    </div>
                    <div class="right">
                        <span class="value-chip" id="frictionVal">0.8</span>
                        <div class="stepper">
                            <button class="step-btn" data-step="-0.1" data-target="friction">-</button>
                            <button class="step-btn" data-step="0.1" data-target="friction">+</button>
                        </div>
                    </div>
                </div>
                <div class="row-slider">
                    <input type="range" class="elastic-slider" id="friction" min="0" max="1" step="0.1" value="0.8" />
                </div>
            </div>

            <div class="section-title">渲染器 Renderer</div>

            <div class="param-row">
                <div class="row-header">
                    <div class="left">
                        <div class="param-label">背景颜色 Background</div>
                    </div>
                    <div class="right">
                        <input type="color" id="backgroundColor" value="#1a1a2e" class="color-picker" />
                    </div>
                </div>
            </div>

            <div class="param-row">
                <div class="row-header">
                    <div class="left">
                        <div class="param-label">帧数 FPS</div>
                    </div>
                    <div class="right">
                        <span class="value-chip" id="fpsVal">60</span>
                        <div class="stepper">
                            <button class="step-btn" data-step="-10" data-target="fps">-</button>
                            <button class="step-btn" data-step="10" data-target="fps">+</button>
                        </div>
                    </div>
                </div>
                <div class="row-slider">
                    <input type="range" class="elastic-slider" id="fps" min="30" max="120" step="10" value="60" />
                </div>
            </div>
        </div>

        <div class="dialog-footer">
            <button class="dialog-btn confirm" onclick="worldSettingsPanel.confirm()">确定</button>
            <button class="dialog-btn cancel" onclick="worldSettingsPanel.hide()">取消</button>
        </div>
    </div>

    <!-- 文件命名对话框 -->
    <div class="floating-window" id="fileNameDialog">
        <div class="drag-handle"></div>
        <button class="close-button" id="fileNameCloseBtn"></button>
        <div class="floating-window-title">保存场景</div>

        <div class="param-item">
            <label for="sceneFileName">文件名</label>
            <input type="text" id="sceneFileName" class="ai-input" placeholder="输入场景文件名...">
        </div>

        <div class="dialog-footer">
            <button class="dialog-btn confirm" id="fileNameConfirmBtn">保存</button>
            <button class="dialog-btn cancel" id="fileNameCancelBtn">取消</button>
        </div>
    </div>


    <!-- 代码编辑器面板 -->
    <div class="floating-window" id="codeEditorPanel">
        <div class="drag-handle"></div>
        <button class="close-button" id="codeEditorCloseBtn"></button>
        <div class="floating-window-title">代码编辑器</div>
        <div class="code-editor-container">
            <textarea id="codeEditor" spellcheck="false"></textarea>
        </div>
        <div class="dialog-footer">
            <button class="dialog-btn" id="codeEditorRunBtn">
                <span class="material-icons">play_arrow</span>
                运行
            </button>
            <button class="dialog-btn" id="codeEditorClearBtn">
                <span class="material-icons">clear_all</span>
                清空
            </button>
        </div>
    </div>

    <!-- 在body中添加这个对话框 -->
    <div class="floating-window" id="elasticDialog">
        <div class="drag-handle"></div>
        <button class="close-button" id="elasticCloseBtn"></button>
        <div class="floating-window-title">选择绳子的弹性系数</div>

        <div class="param-item">
            <label for="elasticSlider">弹性系数 (0-1)</label>
            <div class="slider-container">
                <input type="range" class="elastic-slider" id="elasticSlider" min="0" max="1" step="0.1" value="0.5">
                <div class="slider-value" id="elasticValue">0.5</div>
            </div>
        </div>

        <div class="dialog-footer">
            <button class="dialog-btn confirm" id="elasticConfirmBtn">确认</button>
            <button class="dialog-btn cancel" id="elasticCancelBtn">取消</button>
        </div>
    </div>


    <script>

    </script>


    <script src="/zwz/matter.min.js"></script>
    <script src="/zwz/matter-wrap.js"></script>
    <script src="/zwz/function.js"></script>
    <script src="/zwz/enginer.js"></script>
    <script src="/zwz/demo.js"></script>
    <script src="/zwz/var.js"></script>

    <script>
        Matter.use(
            'matter-wrap'
        );
        var vf;
        function toggleSidebar() {
            const body = document.body;

            if (body.classList.contains('active')) {
                body.classList.remove('active');
            } else {
                body.classList.add('active');
            }
        }
        // 获取按钮元素
        const fullscreenButton = document.getElementById('fullscreenButton');
        var isPaused = false;

        // 在你的游戏循环中，根据 isPaused 标志来决定是否更新引擎
        (function loop() {
            if (!isPaused) {
                Matter.Engine.update(engine);
            }
            // 请求下一帧
            requestAnimationFrame(loop);
        })();

        // 定义一个函数来切换暂停状态
        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                console.log('已暂停');

            } else {
                console.log('已恢复');
            }
        }


        // // 添加点击事件监听器
        // fullscreenButton.addEventListener('click', () => {
        //     if (document.body.requestFullscreen) {
        //         document.body.requestFullscreen();
        //     } else if (document.body.mozRequestFullScreen) { // Firefox
        //         document.body.mozRequestFullScreen();
        //     } else if (document.body.webkitRequestFullscreen) { // Chrome, Safari 和 Opera
        //         document.body.webkitRequestFullscreen();
        //     } else if (document.body.msRequestFullscreen) { // IE/Edge
        //         document.body.msRequestFullscreen();
        //     }
        // });


        // 场景管理（侧边栏）
        (function setupSceneManager() {
            const listEl = document.getElementById('sceneList');
            const btnNew = document.getElementById('btnNewScene');
            const scenes = [];

            function captureMatterImage() {
                const refs = window.__matter;
                if (!refs || !refs.render || !refs.render.canvas) return null;
                const matterCanvas = refs.render.canvas;
                const width = matterCanvas.width;
                const height = matterCanvas.height;
                const copy = document.createElement('canvas');
                copy.width = width;
                copy.height = height;
                const ctx = copy.getContext('2d');
                ctx.drawImage(matterCanvas, 0, 0);
                return copy.toDataURL('image/png');
            }

            function serializeWorldCode() {
                const refs = window.__matter;
                if (!refs) return '';
                const { Matter, world } = refs;
                const bodies = Matter.Composite.allBodies(world);
                const constraints = Matter.Composite.allConstraints(world);
                const lines = [];
                
                lines.push('// 场景代码 - 包含物体和约束');
                lines.push('const createdBodies = new Map();');
                lines.push('// 错误处理函数');
                lines.push('function handleError(message, func) {');
                lines.push('  try {');
                lines.push('    return func();');
                lines.push('  } catch (e) {');
                lines.push('    console.warn(message + ": " + e.message);');
                lines.push('    return null;');
                lines.push('  }');
                lines.push('}');
                
                bodies.forEach((b) => {
                    const opt = {
                        isStatic: !!b.isStatic,
                        restitution: b.restitution,
                        friction: b.friction,
                        frictionAir: b.frictionAir,
                        density: b.density,
                        angle: b.angle,
                        render: b.render
                    };
                    const optStr = JSON.stringify(opt);
                    if (b.circleRadius) {
                        lines.push(`handleError('创建圆形物体', function() {`);
                        lines.push(`  const body = Matter.Bodies.circle(${b.position.x}, ${b.position.y}, ${b.circleRadius}, ${optStr});`);
                        lines.push(`  Matter.World.add(world, body);`);
                        lines.push(`  createdBodies.set('${b.id}', body);`);
                        lines.push(`  return body;`);
                        lines.push(`});`);
                    } else if (b.vertices && b.vertices.length >= 3) {
                        const verts = JSON.stringify(b.vertices.map(v => ({ x: v.x, y: v.y })));
                        lines.push(`handleError('创建多边形物体', function() {`);
                        lines.push(`  const body = Matter.Bodies.fromVertices(${b.position.x}, ${b.position.y}, [${verts}], ${optStr}, true, 0.01, 10);`);
                        lines.push(`  Matter.World.add(world, body);`);
                        lines.push(`  createdBodies.set('${b.id}', body);`);
                        lines.push(`  return body;`);
                        lines.push(`});`);
                    }
                });
                
                constraints.forEach((c, index) => {
                    lines.push(`handleError('创建约束 #${index}', function() {`);
                    lines.push(`  // 确保两个物体都存在`);
                    lines.push(`  const bodyA = ${c.bodyA ? `createdBodies.get('${c.bodyA.id}')` : 'null'};`);
                    lines.push(`  const bodyB = ${c.bodyB ? `createdBodies.get('${c.bodyB.id}')` : 'null'};`);
                    lines.push(`  if (bodyA === undefined || bodyB === undefined) return null;`);
                    
                    const arr = [];
                    if (c.bodyA) arr.push(`bodyA: bodyA`);
                    if (c.bodyB) arr.push(`bodyB: bodyB`);
                    if (c.pointA) arr.push(`pointA: {x:${c.pointA.x}, y:${c.pointA.y}}`);
                    if (c.pointB) arr.push(`pointB: {x:${c.pointB.x}, y:${c.pointB.y}}`);
                    if (typeof c.length !== 'undefined') arr.push(`length:${c.length}`);
                    if (typeof c.stiffness !== 'undefined') arr.push(`stiffness:${c.stiffness}`);
                    if (typeof c.damping !== 'undefined') arr.push(`damping:${c.damping}`);
                    if (typeof c.angleA !== 'undefined') arr.push(`angleA:${c.angleA}`);
                    if (typeof c.angleB !== 'undefined') arr.push(`angleB:${c.angleB}`);
                    if (typeof c.knockback !== 'undefined') arr.push(`knockback:${c.knockback}`);
                    if (typeof c.render !== 'undefined' && c.render) arr.push(`render:${JSON.stringify(c.render)}`);

                    const optStr = `{ ${arr.join(', ')} }`;
                    lines.push(`  const cons = Matter.Constraint.create(${optStr});`);
                    lines.push(`  Matter.World.add(world, cons);`);
                    lines.push(`  return cons;`);
                    lines.push(`});`);
                });
                
                return lines.join('\n');
            }

            function clearWorldKeepMouse() {
                const refs = window.__matter;
                if (!refs) return;
                const { Matter, world } = refs;
                const mc = refs.mouseConstraint;
                Matter.Composite.allBodies(world).forEach(b => { try { Matter.World.remove(world, b); } catch (_) { } });
                Matter.Composite.allConstraints(world).forEach(c => {
                    if (mc && (c === mc || c === mc.constraint)) return;
                    try { Matter.World.remove(world, c); } catch (_) { }
                });
            }

            function addThumbnail(scene) {
                const canvas = document.createElement('canvas');
                const w = listEl.clientWidth - 20; // padding 内估算
                const h = 160;
                canvas.width = w > 0 ? w : 260;
                canvas.height = h;
                Object.assign(canvas.style, {
                    width: '100%',
                    height: h + 'px',
                    margin: '8px 0',
                    borderRadius: '8px',
                    border: '1px solid rgba(255,255,255,0.12)',
                    cursor: 'pointer',
                    background: 'rgba(255,255,255,0.04)'
                });
                const ctx = canvas.getContext('2d');
                const img = new Image();
                img.onload = () => {
                    // 等比缩放居中绘制
                    const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
                    const dw = img.width * scale;
                    const dh = img.height * scale;
                    const dx = (canvas.width - dw) / 2;
                    const dy = (canvas.height - dh) / 2;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0, img.width, img.height, dx, dy, dw, dh);
                };
                img.src = scene.thumbnail;
                // 滑动删除手势
                let startX = 0, deltaX = 0, dragging = false;
                const threshold = 60;
                const onDown = (e) => {
                    dragging = true;
                    startX = (e.touches ? e.touches[0].clientX : e.clientX);
                    deltaX = 0;
                };
                const onMove = (e) => {
                    if (!dragging) return;
                    const x = (e.touches ? e.touches[0].clientX : e.clientX);
                    deltaX = x - startX;
                    // 仅向左滑动产生偏移
                    const offset = Math.min(0, deltaX);
                    canvas.style.transform = `translateX(${offset}px)`;
                    canvas.style.transition = 'transform 0s';
                };
                const onUp = () => {
                    if (!dragging) return;
                    dragging = false;
                    canvas.style.transition = 'transform 0.25s ease';
                    if (deltaX < -threshold) {
                        // 删除该缩略图
                        listEl.removeChild(canvas);
                    } else {
                        // 还原位置
                        canvas.style.transform = 'translateX(0)';
                    }
                };
                canvas.addEventListener('mousedown', onDown);
                canvas.addEventListener('mousemove', onMove);
                canvas.addEventListener('mouseup', onUp);
                canvas.addEventListener('mouseleave', onUp);
                canvas.addEventListener('touchstart', onDown);
                canvas.addEventListener('touchmove', onMove);
                canvas.addEventListener('touchend', onUp);

                // 点击加载（忽略滑动手势偏移较大时）
                canvas.addEventListener('click', (e) => {
                    if (Math.abs(deltaX) > 5) return; // 认为是滑动，不触发点击
                    clearWorldKeepMouse();
                    try {
                        new Function('Matter', 'world', scene.code)(window.__matter.Matter, window.__matter.world);
                    } catch (err) {
                        console.error('场景代码执行失败', err);
                    }
                });
                listEl.appendChild(canvas);
            }

            btnNew.addEventListener('click', () => {
                const dataUrl = captureMatterImage();
                if (!dataUrl) return;
                const code = serializeWorldCode();
                const scene = { id: Date.now(), thumbnail: dataUrl, code };
                scenes.push(scene);
                addThumbnail(scene);
                clearWorldKeepMouse();
            });
        })();

        // 悬浮窗管理
        class FloatingWindowManager {
            constructor() {
                this.window = document.getElementById('floatingWindow');
                this.toolsButton = document.getElementById('toolsButton');
                this.closeButton = document.getElementById('closeButton');
                this.buttonsContainer = document.getElementById('floatingButtons');
                this.dragHandle = document.getElementById('dragHandle');
                this.isVisible = false;
                this.isDragging = false;
                this.dragOffset = { x: 0, y: 0 };
                this.currentPosition = { x: 0, y: 0 };

                this.init();
            }

            init() {
                // 工具按钮点击事件
                this.toolsButton.addEventListener('click', () => {
                    this.toggle();
                });

                // 关闭按钮点击事件
                this.closeButton.addEventListener('click', () => {
                    this.hide();
                });

                // 点击悬浮窗外部关闭
                this.window.addEventListener('click', (e) => {
                    e.stopPropagation();
                });

                document.addEventListener('click', (e) => {
                    if (this.isVisible && !this.window.contains(e.target) && !this.toolsButton.contains(e.target)) {
                        this.hide();
                    }
                });

                // 拖拽功能
                this.initDrag();
            }

            initDrag() {
                // 鼠标按下事件
                this.dragHandle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.startDrag(e);
                });

                // 触摸开始事件（移动端支持）
                this.dragHandle.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.startDrag(e.touches[0]);
                });

                // 鼠标移动事件
                document.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        e.preventDefault();
                        this.drag(e);
                    }
                });

                // 触摸移动事件
                document.addEventListener('touchmove', (e) => {
                    if (this.isDragging) {
                        e.preventDefault();
                        this.drag(e.touches[0]);
                    }
                });

                // 鼠标释放事件
                document.addEventListener('mouseup', () => {
                    if (this.isDragging) {
                        this.endDrag();
                    }
                });

                // 触摸结束事件
                document.addEventListener('touchend', () => {
                    if (this.isDragging) {
                        this.endDrag();
                    }
                });
            }

            startDrag(e) {
                this.isDragging = true;
                this.window.classList.add('dragging');

                const rect = this.window.getBoundingClientRect();
                this.dragOffset.x = e.clientX - rect.left;
                this.dragOffset.y = e.clientY - rect.top;

                // 阻止默认行为
                e.preventDefault();
            }

            drag(e) {
                if (!this.isDragging) return;

                const x = e.clientX - this.dragOffset.x;
                const y = e.clientY - this.dragOffset.y;

                // 限制在视窗范围内
                const maxX = window.innerWidth - this.window.offsetWidth;
                const maxY = window.innerHeight - this.window.offsetHeight;

                this.currentPosition.x = Math.max(0, Math.min(x, maxX));
                this.currentPosition.y = Math.max(0, Math.min(y, maxY));

                this.window.style.left = this.currentPosition.x + 'px';
                this.window.style.top = this.currentPosition.y + 'px';
                this.window.style.transform = 'none';
            }

            endDrag() {
                this.isDragging = false;
                this.window.classList.remove('dragging');
            }

            toggle() {
                if (this.isVisible) {
                    this.hide();
                } else {
                    this.show();
                }
            }

            show() {
                this.window.classList.add('show');
                this.toolsButton.classList.add('active');
                this.isVisible = true;

                // 如果之前有拖拽位置，恢复位置
                if (this.currentPosition.x !== 0 || this.currentPosition.y !== 0) {
                    this.window.style.left = this.currentPosition.x + 'px';
                    this.window.style.top = this.currentPosition.y + 'px';
                    this.window.style.transform = 'none';
                }
            }

            hide() {
                this.window.classList.remove('show');
                this.toolsButton.classList.remove('active');
                this.isVisible = false;
            }

            // 添加按钮到悬浮窗
            addButton(text, icon, onClick) {
                const button = document.createElement('button');
                button.className = 'floating-button';
                button.innerHTML = `
                    <span class="material-icons button-icon">${icon}</span>
                    <span>${text}</span>
                `;

                button.addEventListener('click', onClick);
                this.buttonsContainer.appendChild(button);
                return button;
            }

            // 移除所有按钮
            clearButtons() {
                this.buttonsContainer.innerHTML = '';
            }

            // 移除指定按钮
            removeButton(buttonElement) {
                if (buttonElement && buttonElement.parentNode) {
                    buttonElement.parentNode.removeChild(buttonElement);
                }
            }

            // 批量添加按钮
            addButtons(buttons) {
                buttons.forEach(buttonConfig => {
                    this.addButton(buttonConfig.text, buttonConfig.icon, buttonConfig.onClick);
                });
            }
        }



        // AI面板管理
        class AIPanelManager {
            constructor() {
                this.panel = document.getElementById('aiPanel');
                this.aiButton = document.getElementById('aiButton');
                this.closeButton = document.getElementById('aiCloseButton');
                this.dragHandle = document.getElementById('aiDragHandle');
                this.chatArea = document.getElementById('aiChatArea');
                this.input = document.getElementById('aiInput');
                this.sendBtn = document.getElementById('sendBtn');
                this.uploadBtn = document.getElementById('uploadBtn');
                this.clearBtn = document.getElementById('clearBtn');
                this.aiOptions = document.querySelectorAll('.ai-option');

                this.isVisible = false;
                this.isDragging = false;
                this.dragOffset = { x: 0, y: 0 };
                this.currentPosition = { x: 0, y: 0 };
                this.currentAI = 'niuxiaodun';

                this.init();
            }

            init() {
                // AI按钮点击事件
                this.aiButton.addEventListener('click', () => {
                    this.toggle();
                });

                // 关闭按钮点击事件
                this.closeButton.addEventListener('click', () => {
                    this.hide();
                });

                // 点击面板外部关闭
                this.panel.addEventListener('click', (e) => {
                    e.stopPropagation();
                });

                document.addEventListener('click', (e) => {
                    if (this.isVisible && !this.panel.contains(e.target) && !this.aiButton.contains(e.target)) {
                        this.hide();
                    }
                });

                // 拖拽功能
                this.dragHandle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.startDrag(e);
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        e.preventDefault();
                        this.drag(e);
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (this.isDragging) {
                        this.endDrag();
                    }
                });

                // 发送消息
                this.sendBtn.addEventListener('click', () => {
                    this.sendMessage();
                });

                this.input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });

                // 上传文件
                this.uploadBtn.addEventListener('click', () => {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'image/*';
                    input.onchange = (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            const reader = new FileReader();
                            reader.onload = (event) => {
                                this.addMessage('user', '', event.target.result);
                            };
                            reader.readAsDataURL(file);
                        }
                    };
                    input.click();
                });

                // 清除聊天记录
                this.clearBtn.addEventListener('click', () => {
                    this.chatArea.innerHTML = '';
                });

                // AI选择
                this.aiOptions.forEach(option => {
                    option.addEventListener('click', (e) => {
                        e.preventDefault();
                        // 移除所有active类
                        this.aiOptions.forEach(opt => opt.classList.remove('active'));
                        // 添加active类到当前选项
                        option.classList.add('active');
                        this.selectAI(option.dataset.ai);
                    });
                });
            }

            startDrag(e) {
                this.isDragging = true;
                this.panel.classList.add('dragging');

                const rect = this.panel.getBoundingClientRect();
                this.dragOffset.x = e.clientX - rect.left;
                this.dragOffset.y = e.clientY - rect.top;
            }

            drag(e) {
                if (!this.isDragging) return;

                const x = e.clientX - this.dragOffset.x;
                const y = e.clientY - this.dragOffset.y;

                // 限制在视窗范围内
                const maxX = window.innerWidth - this.panel.offsetWidth;
                const maxY = window.innerHeight - this.panel.offsetHeight;

                this.currentPosition.x = Math.max(0, Math.min(x, maxX));
                this.currentPosition.y = Math.max(0, Math.min(y, maxY));

                this.panel.style.left = this.currentPosition.x + 'px';
                this.panel.style.top = this.currentPosition.y + 'px';
                this.panel.style.transform = 'none';
            }

            endDrag() {
                this.isDragging = false;
                this.panel.classList.remove('dragging');
            }

            toggle() {
                if (this.isVisible) {
                    this.hide();
                } else {
                    this.show();
                }
            }

            show() {
                this.panel.classList.add('show');
                this.aiButton.classList.add('ai-active');
                this.isVisible = true;

                // 如果之前有拖拽位置，恢复位置
                if (this.currentPosition.x !== 0 || this.currentPosition.y !== 0) {
                    this.panel.style.left = this.currentPosition.x + 'px';
                    this.panel.style.top = this.currentPosition.y + 'px';
                    this.panel.style.transform = 'none';
                }
            }

            hide() {
                this.panel.classList.remove('show');
                this.aiButton.classList.remove('ai-active');
                this.isVisible = false;
            }

            sendMessage() {
                const message = this.input.value.trim();
                if (message) {
                    this.addMessage('user', message);
                    this.getAIResponse(message);
                    this.input.value = '';
                }
            }

            addMessage(role, content, imageSrc = '') {
                const messageDiv = document.createElement('div');
                messageDiv.className = `ai-message ${role}`;
                if (imageSrc) {
                    messageDiv.innerHTML = `<img src="${imageSrc}" alt="Uploaded image" class="uploaded-image">`;
                } else {
                    if (role === 'ai') {
                        messageDiv.innerHTML = `<strong>${this.currentAI === 'niuxiaodun' ? '牛小顿' : '七七博士'}：</strong>${content}`;
                    } else {
                        messageDiv.innerHTML = `<strong>用户：</strong>${content}`;
                    }
                }
                this.chatArea.appendChild(messageDiv);
                this.chatArea.scrollTop = this.chatArea.scrollHeight;
            }

            async getAIResponse(message) {
                //这里是AI的实际调用区
                sendMessage(message, this)
                function sendCoze(messages) {
                    const apiAccessToken = "pat_OLHX7ktqgFOoA1VCSSxewBQdaV408Fyf7k58ciUYUDmH0lu6c3q4hYum1kV6u7vK";
                    const chatBotId = "7556832182518431782";  // 机器人 ID，用于区分不同的聊天机器人

                    const url = "https://api.coze.cn/open_api/v2/chat";
                    const headers = {
                        "Authorization": `Bearer ${apiAccessToken}`,
                        "Content-Type": "application/json"
                    };

                    const payload = {
                        "bot_id": chatBotId,
                        "user": "123123123", // user可随意修改
                        "query": messages,
                        "stream": false
                    };

                    return axios.post(url, payload, { headers })
                        .then(response => {
                            const responseData = response.data;

                            const messages = responseData.messages || [];
                            for (const message of messages) {
                                const messageContent = message.content || '';
                                if (!messageContent.startsWith("{") && !messageContent.startsWith("RPCError")) {
                                    console.log(`coze answer: ${messageContent}`);


                                    return messageContent;
                                }
                            }
                            return '';
                        })
                        .catch(error => {
                            console.error('Request failed:', error);
                            throw error;
                        });
                }

                // 发送消息的函数
                function sendMessage(messages, context) {
                    sendCoze(messages)
                        .then(response => {
                            context.addMessage('ai', response);
                            //直接执行函数js脚本
                            eval(response);
                            //设置id为codeEditor的文本为response
                            document.getElementById("codeEditor").value = response;
                        });
                }
            }

            selectAI(aiName) {
                this.currentAI = aiName;
                if (aiName === 'niuxiaodun') {

                }
                else if (aiName === 'qiqibo') {

                }
                // 可以在这里添加切换AI的逻辑
                console.log('Selected AI:', aiName);
            }
        }


        // Canvas画板控制类
        class CanvasPanelManager {
            constructor() {
                this.leftContainer = document.getElementById('leftCanvasContainer');
                this.rightContainer = document.getElementById('rightCanvasContainer');
                this.leftCanvas = document.getElementById('leftCanvas');
                this.rightCanvas = document.getElementById('rightCanvas');
                this.isVisible = false;
                this.isAnimating = false;
                this.draggedElement = null;
                this.dragOffset = { x: 0, y: 0 };

                // per-canvas state
                this.state = {
                    left: {
                        scale: 40, // pixels per world unit
                        autoFit: true,
                        axesVisible: false,
                        origin: null, // set in initCanvas to center
                        points: []
                    },
                    right: {
                        scale: 40,
                        autoFit: true,
                        axesVisible: false,
                        origin: null,
                        points: []
                    }
                };

                this.init();
            }

            init() {
                // 监听键盘事件
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Tab' && !e.repeat) {
                        e.preventDefault();
                        this.togglePanels();
                    }
                });

                // 初始化Canvas
                this.initCanvas();

                // 初始化拖拽功能
                this.initDrag();
            }

            initCanvas() {
                // 尺寸设置（容器 600x300，去掉内边距）
                const canvasWidth = 580;
                const canvasHeight = 250;

                this.leftCanvas.width = canvasWidth;
                this.leftCanvas.height = canvasHeight;
                this.rightCanvas.width = canvasWidth;
                this.rightCanvas.height = canvasHeight;

                // 默认原点为画布中心（像素坐标）
                this.state.left.origin = { x: canvasWidth / 2, y: canvasHeight / 2 };
                this.state.right.origin = { x: canvasWidth / 2, y: canvasHeight / 2 };

                // 初始只绘制黑色格子背景
                this.redraw('left');
                this.redraw('right');
            }

            // 渲染管线
            redraw(side) {
                const canvas = side === 'left' ? this.leftCanvas : this.rightCanvas;
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const st = this.state[side];

                // 清空
                ctx.clearRect(0, 0, width, height);

                // 背景
                ctx.fillStyle = 'rgba(0,0,0,1)';
                ctx.fillRect(0, 0, width, height);

                // 画黑底上的浅色格子（固定屏幕像素间隔，不随缩放改变视觉密度）
                this.drawGrid(ctx, width, height, 40);

                // 坐标轴
                if (st.axesVisible) {
                    this.drawAxes(ctx, width, height, st);
                }

                // 点
                for (const p of st.points) {
                    this.drawPoint(ctx, st, p.x, p.y, p.color);
                }
            }

            drawGrid(ctx, width, height, spacingPx) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
                ctx.lineWidth = 1;
                for (let x = 0; x <= width; x += spacingPx) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }
                for (let y = 0; y <= height; y += spacingPx) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
            }

            drawAxes(ctx, width, height, st) {
                const { x: ox, y: oy } = st.origin;
                ctx.strokeStyle = 'rgba(255,255,255,0.7)';
                ctx.lineWidth = 2;
                // X 轴
                ctx.beginPath();
                ctx.moveTo(0, oy);
                ctx.lineTo(width, oy);
                ctx.stroke();
                // Y 轴
                ctx.beginPath();
                ctx.moveTo(ox, 0);
                ctx.lineTo(ox, height);
                ctx.stroke();
            }

            worldToScreen(st, x, y) {
                return {
                    sx: st.origin.x + x * st.scale,
                    sy: st.origin.y - y * st.scale
                };
            }

            drawPoint(ctx, st, x, y, color) {
                const { sx, sy } = this.worldToScreen(st, x, y);
                ctx.fillStyle = color || '#00ffff';
                ctx.beginPath();
                ctx.arc(sx, sy, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // 公共 API
            createAxes(side, options = {}) {
                const st = this.state[side];
                if (!st) return;
                const canvas = side === 'left' ? this.leftCanvas : this.rightCanvas;
                const width = canvas.width;
                const height = canvas.height;
                st.axesVisible = true;
                if (options.origin === 'center' || !options.origin) {
                    st.origin = { x: width / 2, y: height / 2 };
                } else if (options.origin && typeof options.origin.x === 'number' && typeof options.origin.y === 'number') {
                    st.origin = { x: options.origin.x, y: options.origin.y };
                }
                if (typeof options.scale === 'number' && options.scale > 0) {
                    st.scale = options.scale;
                }
                this.redraw(side);
            }

            plotPoint(side, x, y, color = '#00ffff') {
                const st = this.state[side];
                if (!st) return;
                st.points.push({ x, y, color });
                if (st.autoFit) this.autoFitToInclude(side, x, y);
                this.redraw(side);
            }

            autoFitToInclude(side, x, y) {
                const st = this.state[side];
                const canvas = side === 'left' ? this.leftCanvas : this.rightCanvas;
                const pad = 20;
                const width = canvas.width;
                const height = canvas.height;

                const needScaleForX = x !== 0 ? (width / 2 - pad) / Math.abs(x) : Infinity;
                const needScaleForY = y !== 0 ? (height / 2 - pad) / Math.abs(y) : Infinity;
                const required = Math.min(needScaleForX, needScaleForY);
                if (required !== Infinity && required < st.scale) {
                    st.scale = required; // 缩小以容纳新点
                }
            }

            setZoom(side, factor) {
                const st = this.state[side];
                if (!st) return;
                const newScale = Math.max(1, Math.min(1000, st.scale * factor));
                st.scale = newScale;
                this.redraw(side);
            }

            setAutoFit(enabled) {
                this.state.left.autoFit = !!enabled;
                this.state.right.autoFit = !!enabled;
            }

            initDrag() {
                // 为两个容器添加拖拽事件
                [this.leftContainer, this.rightContainer].forEach(container => {
                    container.addEventListener('mousedown', (e) => {
                        if (e.target.classList.contains('canvas-close-btn')) return;
                        this.startDrag(e, container);
                    });
                });

                document.addEventListener('mousemove', (e) => {
                    this.drag(e);
                });

                document.addEventListener('mouseup', () => {
                    this.endDrag();
                });
            }

            startDrag(e, element) {
                this.draggedElement = element;
                element.classList.add('dragging');

                const rect = element.getBoundingClientRect();
                this.dragOffset.x = e.clientX - rect.left;
                this.dragOffset.y = e.clientY - rect.top;
            }

            drag(e) {
                if (!this.draggedElement) return;

                const x = e.clientX - this.dragOffset.x;
                const y = e.clientY - this.dragOffset.y;

                // 限制在视窗范围内
                const maxX = window.innerWidth - this.draggedElement.offsetWidth;
                const maxY = window.innerHeight - this.draggedElement.offsetHeight;

                const constrainedX = Math.max(0, Math.min(x, maxX));
                const constrainedY = Math.max(0, Math.min(y, maxY));

                this.draggedElement.style.left = constrainedX + 'px';
                this.draggedElement.style.top = constrainedY + 'px';
                this.draggedElement.style.transform = 'none';
            }

            endDrag() {
                if (this.draggedElement) {
                    this.draggedElement.classList.remove('dragging');
                    this.draggedElement = null;
                }
            }

            togglePanels() {
                if (this.isAnimating) return;

                if (this.isVisible) {
                    this.hidePanels();
                } else {
                    this.showPanels();
                }
            }

            showPanels() {
                if (this.isAnimating) return;

                this.isAnimating = true;

                // 添加延迟，让两个面板依次出现
                this.leftContainer.classList.add('show');

                setTimeout(() => {
                    this.rightContainer.classList.add('show');
                    this.isVisible = true;
                    this.isAnimating = false;
                }, 200);
            }

            hidePanels() {
                if (this.isAnimating) return;

                this.isAnimating = true;

                // 添加延迟，让两个面板依次消失
                this.rightContainer.classList.remove('show');

                setTimeout(() => {
                    this.leftContainer.classList.remove('show');
                    this.isVisible = false;
                    this.isAnimating = false;
                }, 200);
            }
        }

        // 初始化画板管理器
        const canvasPanelManager = new CanvasPanelManager();

        // 将画板管理器暴露到全局
        window.canvasPanelManager = canvasPanelManager;

        // 简单的绘图 API 暴露
        const physicsPlot = {
            createAxes: (side, options) => canvasPanelManager.createAxes(side, options),
            plotPoint: (side, x, y, color) => canvasPanelManager.plotPoint(side, x, y, color),
            setZoom: (side, factor) => canvasPanelManager.setZoom(side, factor),
            setAutoFit: (enabled) => canvasPanelManager.setAutoFit(enabled)
        };
        window.physicsPlot = physicsPlot;

        // 创建AI面板管理器实例
        const aiPanel = new AIPanelManager();

        // 将AI面板管理器暴露到全局
        window.aiPanel = aiPanel;
        /*变量声明区*/

        var timeline = false;



        // 创建悬浮窗管理器实例
        const floatingWindow = new FloatingWindowManager();

        // 添加8个功能工具按钮
        floatingWindow.addButtons([
            {
                text: '动态矢量',
                icon: 'timeline',
                onClick: () => {
                    timeline = !timeline;
                    window.alertDialog.alert('选择为物体添加动态矢量\n请选择需要设置的物体', '提示', 2000);
                    //隐藏工具面板
                    floatingWindow.hide();
                    mode = 0;
                }
            },
            {
                text: '无限场景',
                icon: 'all_inclusive',
                onClick: () => {
                    window.alertDialog.alert('选择为物体添加无限场景\n请选择需要设置的物体', '提示', 2000);
                    floatingWindow.hide();
                    mode = 1;
                }
            },
            {
                text: '添加轨迹',
                icon: 'track_changes',
                onClick: () => {
                    window.alertDialog.alert('为物体添加轨迹（随机）', '提示', 2000);
                    mode = 2;
                }
            },
            {
                text: '世界设置',
                icon: 'settings',
                onClick: () => {
                    console.log('世界设置工具被点击');
                    floatingWindow.hide();
                    window.openWorldSettingsPanel();
                }
            },
            {
                text: '固定',
                icon: 'lock',
                onClick: () => {
                    console.log('固定工具被点击');
                    floatingWindow.hide();
                    mode = 3;

                }
            },
            {
                text: '删除',
                icon: 'delete',
                onClick: () => {
                    window.alertDialog.alert('选择删除的物体\n鼠标点击删除的物体', '提示', 2000);
                    //隐藏工具面板
                    floatingWindow.hide();
                    mode = 5
                }
            },
            {
                text: '连接',
                icon: 'link',
                onClick: () => {
                    mode = 6
                    floatingWindow.hide();
                    window.alertDialog.alert('选择连接的物体\n鼠标点击连接的物体', '提示', 2000);
                }
            },
            {
                text: '添加速度',
                icon: 'speed',
                onClick: () => {
                    mode = 7
                    floatingWindow.hide();
                    window.alertDialog.alert('选择物体添加速度\n鼠标点击物体', '提示', 2000);
                    dd = !dd
                    if (dd) {
                        window.alertDialog.alert('开启', '提示', 2000);
                    }
                    if (!dd) {
                        window.alertDialog.alert('关闭', '提示', 2000);

                    }



                }
            },
            {
                text: '电磁模拟',
                icon: 'electric_bolt',
                onClick: () => {
                    //打开外部fangzhi
                    window.open('electromagnetic_simulation.html', '_blank');
                }
            },
            {
                text: '添加拓展',
                icon: 'more_horiz',
                onClick: () => {
                     window.alertDialog.alert('关闭', '您可以在屏幕中间的导入按钮里面来导入下载好的拓展', 2000);
                }
            }
        ]);

        // 将悬浮窗管理器暴露到全局，方便外部调用
        window.floatingWindow = floatingWindow;


        // 对话警示框管理
        class AlertDialogManager {
            constructor() {
                this.dialog = document.getElementById('alertDialog');
                this.icon = document.getElementById('alertIcon');
                this.title = document.getElementById('alertTitle');
                this.message = document.getElementById('alertMessage');
                this.buttons = document.getElementById('alertButtons');
                this.confirmBtn = document.getElementById('alertConfirm');

                this.isVisible = false;
                this.autoHideTimer = null;

                this.init();
            }

            init() {
                // 确认按钮点击事件
                this.confirmBtn.addEventListener('click', () => {
                    this.hide();
                });

                // 点击对话框外部关闭
                this.dialog.addEventListener('click', (e) => {
                    e.stopPropagation();
                });

                document.addEventListener('click', (e) => {
                    if (this.isVisible && !this.dialog.contains(e.target)) {
                        this.hide();
                    }
                });

                // ESC键关闭
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.isVisible) {
                        this.hide();
                    }
                });
            }

            show(options = {}) {
                const {
                    title = '提示',
                    message = '这是一个警示消息',
                    icon = '⚠️',
                    confirmText = '确定',
                    showCancel = false,
                    cancelText = '取消',
                    autoHide = false,
                    duration = 3000,
                    onConfirm = null,
                    onCancel = null
                } = options;

                // 设置内容
                this.title.textContent = title;
                this.message.textContent = message;
                this.icon.textContent = icon;
                this.confirmBtn.textContent = confirmText;

                // 设置按钮
                this.setupButtons(showCancel, cancelText, onConfirm, onCancel);

                // 显示对话框
                this.dialog.classList.add('show');
                this.isVisible = true;

                // 自动隐藏
                if (autoHide) {
                    this.autoHideTimer = setTimeout(() => {
                        this.hide();
                    }, duration);
                }
            }

            setupButtons(showCancel, cancelText, onConfirm, onCancel) {
                // 清空按钮
                this.buttons.innerHTML = '';

                // 确认按钮
                const confirmBtn = document.createElement('button');
                confirmBtn.className = 'alert-dialog-btn primary';
                confirmBtn.textContent = this.confirmBtn.textContent;
                confirmBtn.addEventListener('click', () => {
                    if (onConfirm) onConfirm();
                    this.hide();
                });
                this.buttons.appendChild(confirmBtn);

                // 取消按钮
                if (showCancel) {
                    const cancelBtn = document.createElement('button');
                    cancelBtn.className = 'alert-dialog-btn';
                    cancelBtn.textContent = cancelText;
                    cancelBtn.addEventListener('click', () => {
                        if (onCancel) onCancel();
                        this.hide();
                    });
                    this.buttons.appendChild(cancelBtn);
                }
            }

            hide() {
                this.dialog.classList.remove('show');
                this.isVisible = false;

                // 清除自动隐藏定时器
                if (this.autoHideTimer) {
                    clearTimeout(this.autoHideTimer);
                    this.autoHideTimer = null;
                }
            }

            // 便捷方法
            alert(message, title = '提示', duration = 0) {
                this.show({
                    title,
                    message,
                    icon: '⚠️',
                    autoHide: duration > 0,
                    duration
                });
            }

            success(message, title = '成功', duration = 0) {
                this.show({
                    title,
                    message,
                    icon: '✅',
                    autoHide: duration > 0,
                    duration
                });
            }

            error(message, title = '错误', duration = 0) {
                this.show({
                    title,
                    message,
                    icon: '❌',
                    autoHide: duration > 0,
                    duration
                });
            }

            info(message, title = '信息', duration = 0) {
                this.show({
                    title,
                    message,
                    icon: 'ℹ️',
                    autoHide: duration > 0,
                    duration
                });
            }

            confirm(message, title = '确认', onConfirm = null, onCancel = null) {
                this.show({
                    title,
                    message,
                    icon: '❓',
                    showCancel: true,
                    onConfirm,
                    onCancel
                });
            }
        }

        // 创建对话警示框管理器实例
        const alertDialog = new AlertDialogManager();

        // 将对话警示框管理器暴露到全局
        window.alertDialog = alertDialog;

        // 示例用法（可以删除）
        // window.alertDialog.alert('这是一个警告消息', '警告', 3000);
        // window.alertDialog.success('操作成功！', '成功', 2000);
        // window.alertDialog.error('操作失败！', '错误', 0);
        // window.alertDialog.confirm('确定要执行此操作吗？', '确认',
        //     () => console.log('用户点击了确定'),
        //     () => console.log('用户点击了取消')
        // );

        // 底部工具栏管理
        class BottomToolbarManager {
            constructor() {
                this.drawingBtn = document.getElementById('drawingBtn');
                this.playBtn = document.getElementById('playBtn');
                this.importBtn = document.getElementById('importBtn');
                this.plotToggleBtn = document.getElementById('plotToggleBtn');
                this.fullscreenToggleBtn = document.getElementById('fullscreenToggleBtn');
                this.drawingPanel = document.getElementById('drawingPanel');
                this.fileCurtain = document.getElementById('fileCurtain');

                this.isDrawingActive = false;
                this.isPlaying = false;
                this.currentFile = null;

                this.init();
            }

            init() {
                // 笔工具按钮
                this.drawingBtn.addEventListener('click', () => {
                    this.toggleDrawing();
                });

                // 开始按钮
                this.playBtn.addEventListener('click', () => {
                    this.togglePlay();
                });

                // 文件导入按钮
                this.importBtn.addEventListener('click', () => {
                    this.importFile();
                });

                // 物理画板开关按钮（替代空格快捷键）
                this.plotToggleBtn.addEventListener('click', () => {
                    if (window.canvasPanelManager) {
                        window.canvasPanelManager.togglePanels();
                    }
                });

                // 全屏切换按钮
                this.fullscreenToggleBtn.addEventListener('click', () => {
                    if (!document.fullscreenElement) {
                        if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();
                        this.fullscreenToggleBtn.innerHTML = '<span class="material-icons">fullscreen_exit</span>';
                    } else {
                        if (document.exitFullscreen) document.exitFullscreen();
                        this.fullscreenToggleBtn.innerHTML = '<span class="material-icons">fullscreen</span>';
                    }
                });

                // 初始化绘图工具
                this.initDrawingTools();
            }

            toggleDrawing() {
                if (!this.drawOverlay) {
                    this.drawOverlay = new DrawOverlayManager();
                }
                if (this.drawOverlay.isShown) {
                    this.drawOverlay.hide();
                    this.drawingBtn.classList.remove('active');
                } else {
                    this.drawOverlay.show();
                    this.drawingBtn.classList.add('active');
                }
            }

            togglePlay() {
                this.isPlaying = !this.isPlaying;

                if (this.isPlaying) {
                    this.playBtn.innerHTML = '<span class="material-icons">pause</span>';
                    this.playBtn.classList.add('active');
                } else {
                    this.playBtn.innerHTML = '<span class="material-icons">play_arrow</span>';
                    this.playBtn.classList.remove('active');
                }
            }

            importFile() {
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.js';
                fileInput.style.display = 'none';

                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = () => {
                        const code = String(reader.result || '');
                        try {
                            new Function(code)();
                            if (window.alertDialog && window.alertDialog.success) {
                                window.alertDialog.success('脚本已运行: ' + file.name, '导入成功', 2000);
                            }
                        } catch (err) {
                            console.error('运行导入脚本出错', err);
                            if (window.alertDialog && window.alertDialog.error) {
                                window.alertDialog.error('脚本运行失败: ' + err.message, '错误', 0);
                            } else {
                                alert('脚本运行失败: ' + err.message);
                            }
                        }
                    };
                    reader.onerror = () => {
                        if (window.alertDialog && window.alertDialog.error) {
                            window.alertDialog.error('无法读取文件', '错误', 0);
                        }
                    };
                    reader.readAsText(file, 'utf-8');
                });

                document.body.appendChild(fileInput);
                fileInput.click();
                document.body.removeChild(fileInput);
            }

            openFile(file) {
                this.currentFile = file;
                document.getElementById('fileTitle').textContent = file.name;
                this.fileCurtain.classList.add('show');

                // 这里可以添加文件解析和显示逻辑
                this.displayFile(file);
            }

            displayFile(file) {
                const fileCanvas = document.getElementById('fileCanvas');
                const drawingCanvas = document.getElementById('drawingCanvas');

                // 设置画布大小
                const width = fileCanvas.offsetWidth;
                const height = fileCanvas.offsetHeight;

                drawingCanvas.width = width;
                drawingCanvas.height = height;

                const ctx = drawingCanvas.getContext('2d');

                // 简单的文件预览（实际项目中需要更复杂的解析）
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, width, height);

                ctx.fillStyle = '#333';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(file.name, width / 2, height / 2);
                ctx.fillText(`大小: ${(file.size / 1024 / 1024).toFixed(2)} MB`, width / 2, height / 2 + 40);
            }

            initDrawingTools() {
                const tools = document.querySelectorAll('.tool-btn');
                const colorPicker = document.getElementById('colorPicker');
                const brushSize = document.getElementById('brushSize');

                tools.forEach(tool => {
                    tool.addEventListener('click', () => {
                        tools.forEach(t => t.classList.remove('active'));
                        tool.classList.add('active');
                        this.currentTool = tool.dataset.tool;
                    });
                });

                this.currentTool = 'brush';
                this.currentColor = colorPicker.value;
                this.currentSize = parseInt(brushSize.value);

                colorPicker.addEventListener('change', (e) => {
                    this.currentColor = e.target.value;
                });

                brushSize.addEventListener('input', (e) => {
                    this.currentSize = parseInt(e.target.value);
                });
            }

            initDrawingCanvas() {
                const canvas = document.getElementById('drawingCanvas');
                const fileCanvas = document.getElementById('fileCanvas');

                // 等待DOM更新后设置画布大小
                setTimeout(() => {
                    canvas.width = fileCanvas.offsetWidth;
                    canvas.height = fileCanvas.offsetHeight;
                }, 100);

                const ctx = canvas.getContext('2d');
                let isDrawing = false;
                let startX, startY;

                // 鼠标事件
                canvas.addEventListener('mousedown', (e) => {
                    isDrawing = true;
                    startX = e.offsetX;
                    startY = e.offsetY;

                    if (this.currentTool === 'brush') {
                        this.drawBrush(ctx, e.offsetX, e.offsetY);
                    }
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (!isDrawing) return;

                    if (this.currentTool === 'brush') {
                        this.drawBrush(ctx, e.offsetX, e.offsetY);
                    }
                });

                canvas.addEventListener('mouseup', () => {
                    isDrawing = false;
                });

                // 触摸事件（移动端支持）
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    isDrawing = true;
                    startX = touch.clientX - rect.left;
                    startY = touch.clientY - rect.top;

                    if (this.currentTool === 'brush') {
                        this.drawBrush(ctx, startX, startY);
                    }
                });

                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!isDrawing) return;

                    const touch = e.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;

                    if (this.currentTool === 'brush') {
                        this.drawBrush(ctx, x, y);
                    }
                });

                canvas.addEventListener('touchend', () => {
                    isDrawing = false;
                });
            }

            drawBrush(ctx, x, y) {
                ctx.globalCompositeOperation = this.currentTool === 'eraser' ? 'destination-out' : 'source-over';
                ctx.strokeStyle = this.currentColor;
                ctx.lineWidth = this.currentSize;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y);
                ctx.stroke();
            }
        }

        // 全屏绘图覆盖层管理
        class DrawOverlayManager {
            constructor() {
                this.isShown = false;
                this.currentTool = 'brush';
                this.currentColor = '#ff3b30';
                this.currentSize = 6;
                this.transparentBg = true;
                this._createDOM();
                this._bindEvents();
            }

            _createDOM() {
                this.container = document.createElement('div');
                Object.assign(this.container.style, {
                    position: 'fixed',
                    left: '0',
                    top: '0',
                    width: '100vw',
                    height: '100vh',
                    zIndex: '10000',
                    pointerEvents: 'none',
                    transform: 'translateY(-110%)',
                    transition: 'transform 420ms cubic-bezier(0.2, 0.9, 0.2, 1.2)',
                });

                this.panel = document.createElement('div');
                Object.assign(this.panel.style, {
                    position: 'absolute',
                    inset: '0',
                    background: 'transparent',
                    pointerEvents: 'auto'
                });
                this.container.appendChild(this.panel);

                // 三层画布：背景层、绘制层、预览层
                this.bgCanvas = document.createElement('canvas');
                Object.assign(this.bgCanvas.style, {
                    position: 'absolute',
                    inset: '0',
                    width: '100%',
                    height: '100%'
                });
                this.panel.appendChild(this.bgCanvas);

                this.drawCanvas = document.createElement('canvas');
                Object.assign(this.drawCanvas.style, {
                    position: 'absolute',
                    inset: '0',
                    width: '100%',
                    height: '100%',
                    cursor: 'crosshair'
                });
                this.panel.appendChild(this.drawCanvas);

                this.previewCanvas = document.createElement('canvas');
                Object.assign(this.previewCanvas.style, {
                    position: 'absolute',
                    inset: '0',
                    width: '100%',
                    height: '100%',
                    pointerEvents: 'none'
                });
                this.panel.appendChild(this.previewCanvas);

                this.toolbar = document.createElement('div');
                Object.assign(this.toolbar.style, {
                    position: 'absolute',
                    bottom: '16px',
                    left: '50%',
                    transform: 'translateX(-50%)',
                    display: 'flex',
                    gap: '10px',
                    padding: '10px 12px',
                    background: 'rgba(0,0,0,0.65)',
                    backdropFilter: 'blur(12px)',
                    WebkitBackdropFilter: 'blur(12px)',
                    borderRadius: '14px',
                    alignItems: 'center',
                    color: '#fff',
                    border: '1px solid rgba(255,255,255,0.08)'
                });

                this._toolButtons = {};
                const iconFor = (tool) => ({
                    brush: 'draw',
                    eraser: 'backspace',
                    line: 'show_chart',
                    rect: 'crop_square',
                    circle: 'radio_button_unchecked',
                    arrow: 'trending_flat',
                    axes: 'grid_4x4'
                })[tool] || 'draw';

                const makeBtn = (label, tool) => {
                    const btn = document.createElement('button');
                    btn.innerHTML = `<span class="material-icons" style="font-size:20px;vertical-align:middle;">${iconFor(tool)}</span>`;
                    btn.title = label;
                    Object.assign(btn.style, {
                        width: '40px',
                        height: '40px',
                        padding: '0',
                        border: 'none',
                        borderRadius: '10px',
                        background: 'rgba(255,255,255,0.06)',
                        color: '#ffffff',
                        cursor: 'pointer',
                        fontWeight: '600',
                        display: 'inline-flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        border: '1px solid rgba(255,255,255,0.06)'
                    });
                    btn.addEventListener('mouseover', () => btn.style.background = 'rgba(255,255,255,0.12)');
                    btn.addEventListener('mouseout', () => {
                        btn.style.background = (this.currentTool === tool) ? 'rgba(255,255,255,0.18)' : 'rgba(255,255,255,0.06)';
                        btn.style.color = '#ffffff';
                    });
                    btn.addEventListener('click', () => this.setTool(tool));
                    this._toolButtons[tool] = btn;
                    return btn;
                };

                this.toolbar.appendChild(makeBtn('画笔', 'brush'));
                this.toolbar.appendChild(makeBtn('橡皮', 'eraser'));
                this.toolbar.appendChild(makeBtn('直线', 'line'));
                this.toolbar.appendChild(makeBtn('矩形', 'rect'));
                this.toolbar.appendChild(makeBtn('圆形', 'circle'));
                this.toolbar.appendChild(makeBtn('箭头', 'arrow'));
                this.toolbar.appendChild(makeBtn('坐标系', 'axes'));

                this.colorInput = document.createElement('input');
                this.colorInput.type = 'color';
                this.colorInput.value = this.currentColor;
                Object.assign(this.colorInput.style, { width: '34px', height: '34px', border: 'none', padding: '0', background: 'transparent' });
                this.colorInput.addEventListener('input', (e) => {
                    this.currentColor = e.target.value;
                });
                this.toolbar.appendChild(this.colorInput);

                this.sizeInput = document.createElement('input');
                this.sizeInput.type = 'range';
                this.sizeInput.min = '1';
                this.sizeInput.max = '40';
                this.sizeInput.value = String(this.currentSize);
                Object.assign(this.sizeInput.style, { width: '160px' });
                this.sizeInput.addEventListener('input', (e) => {
                    this.currentSize = parseInt(e.target.value);
                });
                this.toolbar.appendChild(this.sizeInput);

                this.bgToggle = document.createElement('button');
                this.bgToggle.textContent = '透明';
                this.bgToggle.title = '透明背景: 开/关';
                Object.assign(this.bgToggle.style, {
                    height: '40px',
                    padding: '0 12px',
                    border: 'none',
                    borderRadius: '8px',
                    background: 'rgba(255,255,255,0.06)',
                    color: '#fff',
                    cursor: 'pointer',
                    display: 'inline-flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    border: '1px solid rgba(255,255,255,0.06)'
                });
                this.bgToggle.addEventListener('click', () => this.toggleBackground());
                this.toolbar.appendChild(this.bgToggle);

                const clearBtn = document.createElement('button');
                clearBtn.textContent = '清空';
                clearBtn.title = '清空';
                Object.assign(clearBtn.style, { height: '40px', padding: '0 12px', border: 'none', borderRadius: '8px', background: 'rgba(255,255,255,0.06)', color: '#fff', cursor: 'pointer', display: 'inline-flex', alignItems: 'center', justifyContent: 'center', border: '1px solid rgba(255,255,255,0.06)' });
                clearBtn.addEventListener('click', () => this.clear());
                this.toolbar.appendChild(clearBtn);

                const closeBtn = document.createElement('button');
                closeBtn.innerHTML = '<span class="material-icons" style="font-size:22px;vertical-align:middle;">close</span>';
                closeBtn.title = '关闭';
                Object.assign(closeBtn.style, { width: '40px', height: '40px', padding: '0', border: 'none', borderRadius: '8px', background: 'rgba(255,255,255,0.06)', color: '#fff', cursor: 'pointer', display: 'inline-flex', alignItems: 'center', justifyContent: 'center', border: '1px solid rgba(255,255,255,0.06)' });
                closeBtn.addEventListener('click', () => this.hide());
                this.toolbar.appendChild(closeBtn);

                this.panel.appendChild(this.toolbar);

                document.body.appendChild(this.container);
                this._resizeCanvas();
            }

            _setActiveToolButton() {
                Object.keys(this._toolButtons || {}).forEach(key => {
                    const btn = this._toolButtons[key];
                    if (!btn) return;
                    if (key === this.currentTool) {
                        btn.style.background = '#2196F3';
                        btn.style.color = '#fff';
                    } else {
                        btn.style.background = 'rgba(33,150,243,0.14)';
                        btn.style.color = '#e6f2ff';
                    }
                });
            }

            _bindEvents() {
                window.addEventListener('resize', () => this._resizeCanvas());

                const drawCtx = () => this.drawCanvas.getContext('2d');
                const previewCtx = () => this.previewCanvas.getContext('2d');
                let drawing = false;
                let startX = 0, startY = 0;
                let lastX = 0, lastY = 0;

                const getPos = (e) => {
                    const rect = this.drawCanvas.getBoundingClientRect();
                    if (e.touches && e.touches[0]) {
                        return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
                    }
                    return { x: e.offsetX !== undefined ? e.offsetX : e.clientX - rect.left, y: e.offsetY !== undefined ? e.offsetY : e.clientY - rect.top };
                };

                const drawPreview = (x, y) => {
                    const context = previewCtx();
                    if (!context) return;
                    // 清除预览层
                    context.clearRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);
                    context.save();
                    context.strokeStyle = this.currentColor;
                    context.lineWidth = this.currentSize;
                    context.lineCap = 'round';
                    context.lineJoin = 'round';
                    if (this.currentTool === 'line') {
                        context.beginPath();
                        context.moveTo(startX, startY);
                        context.lineTo(x, y);
                        context.stroke();
                    } else if (this.currentTool === 'rect') {
                        context.strokeRect(Math.min(startX, x), Math.min(startY, y), Math.abs(x - startX), Math.abs(y - startY));
                    } else if (this.currentTool === 'circle') {
                        const r = Math.hypot(x - startX, y - startY);
                        context.beginPath();
                        context.arc(startX, startY, r, 0, Math.PI * 2);
                        context.stroke();
                    } else if (this.currentTool === 'arrow') {
                        this._drawArrow(context, startX, startY, x, y);
                    } else if (this.currentTool === 'axes') {
                        const lenX = Math.abs(x - startX);
                        const lenY = Math.abs(y - startY);
                        this._drawAxes(context, startX, startY, lenX, lenY);
                    }
                    context.restore();
                };

                const commitShape = (x, y) => {
                    const context = drawCtx();
                    if (!context) return;
                    context.save();
                    context.strokeStyle = this.currentColor;
                    context.lineWidth = this.currentSize;
                    context.lineCap = 'round';
                    context.lineJoin = 'round';
                    if (this.currentTool === 'line') {
                        context.beginPath();
                        context.moveTo(startX, startY);
                        context.lineTo(x, y);
                        context.stroke();
                    } else if (this.currentTool === 'rect') {
                        context.strokeRect(Math.min(startX, x), Math.min(startY, y), Math.abs(x - startX), Math.abs(y - startY));
                    } else if (this.currentTool === 'circle') {
                        const r = Math.hypot(x - startX, y - startY);
                        context.beginPath();
                        context.arc(startX, startY, r, 0, Math.PI * 2);
                        context.stroke();
                    } else if (this.currentTool === 'arrow') {
                        this._drawArrow(context, startX, startY, x, y);
                    } else if (this.currentTool === 'axes') {
                        const lenX = Math.abs(x - startX);
                        const lenY = Math.abs(y - startY);
                        this._drawAxes(context, startX, startY, lenX, lenY);
                    }
                    context.restore();
                    // 清除预览层
                    previewCtx().clearRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);
                    this._pushHistory();
                };

                const begin = (e) => {
                    drawing = true;
                    const p = getPos(e);
                    startX = lastX = p.x;
                    startY = lastY = p.y;
                    if (this.currentTool === 'brush' || this.currentTool === 'eraser') {
                        const context = drawCtx();
                        context.save();
                        context.globalCompositeOperation = (this.currentTool === 'eraser') ? 'destination-out' : 'source-over';
                        context.strokeStyle = this.currentColor;
                        context.lineWidth = this.currentSize;
                        context.lineCap = 'round';
                        context.lineJoin = 'round';
                        context.beginPath();
                        context.moveTo(p.x, p.y);
                        context.lineTo(p.x, p.y);
                        context.stroke();
                        context.restore();
                    }
                };

                const move = (e) => {
                    if (!drawing) return;
                    const p = getPos(e);
                    if (this.currentTool === 'brush' || this.currentTool === 'eraser') {
                        const context = drawCtx();
                        context.save();
                        context.globalCompositeOperation = (this.currentTool === 'eraser') ? 'destination-out' : 'source-over';
                        context.strokeStyle = this.currentColor;
                        context.lineWidth = this.currentSize;
                        context.lineCap = 'round';
                        context.lineJoin = 'round';
                        context.beginPath();
                        context.moveTo(lastX, lastY);
                        context.lineTo(p.x, p.y);
                        context.stroke();
                        context.restore();
                        lastX = p.x; lastY = p.y;
                    } else {
                        drawPreview(p.x, p.y);
                    }
                };

                const end = (e) => {
                    if (!drawing) return;
                    drawing = false;
                    const p = getPos(e);
                    if (this.currentTool !== 'brush' && this.currentTool !== 'eraser') {
                        commitShape(p.x, p.y);
                    }
                };

                this.drawCanvas.addEventListener('mousedown', begin);
                this.drawCanvas.addEventListener('mousemove', move);
                this.drawCanvas.addEventListener('mouseup', end);
                this.drawCanvas.addEventListener('mouseleave', end);

                this.drawCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); begin(e); });
                this.drawCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); move(e); });
                this.drawCanvas.addEventListener('touchend', (e) => { e.preventDefault(); end(e); });
            }

            _resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const w = Math.floor(window.innerWidth * dpr);
                const h = Math.floor(window.innerHeight * dpr);
                [this.bgCanvas, this.drawCanvas, this.previewCanvas].forEach(cv => {
                    cv.width = w;
                    cv.height = h;
                    cv.getContext('2d').setTransform(dpr, 0, 0, dpr, 0, 0);
                });
                if (!this.transparentBg) this._fillBackground(); else this._clearBackground();
            }

            _fillBackground() {
                const ctx = this.bgCanvas.getContext('2d');
                ctx.save();
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, this.bgCanvas.width, this.bgCanvas.height);
                ctx.restore();
            }

            _clearBackground() {
                const ctx = this.bgCanvas.getContext('2d');
                ctx.clearRect(0, 0, this.bgCanvas.width, this.bgCanvas.height);
            }

            // 撤回功能已移除

            setTool(tool) { this.currentTool = tool; this._setActiveToolButton(); }

            toggleBackground() {
                this.transparentBg = !this.transparentBg;
                this.bgToggle.textContent = '透明背景: ' + (this.transparentBg ? '开' : '关');
                if (!this.transparentBg) this._fillBackground(); else this._clearBackground();
            }

            clear() {
                this.drawCanvas.getContext('2d').clearRect(0, 0, this.drawCanvas.width, this.drawCanvas.height);
                this.previewCanvas.getContext('2d').clearRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);
                if (!this.transparentBg) this._fillBackground(); else this._clearBackground();
            }

            show() {
                this.isShown = true;
                this.container.style.transform = 'translateY(0)';
                this.container.style.pointerEvents = 'auto';
                this._resizeCanvas();
            }

            hide() {
                this.isShown = false;
                this.container.style.transform = 'translateY(-110%)';
                this.container.style.pointerEvents = 'none';
            }

            _drawArrow(ctx, x1, y1, x2, y2) {
                const headLen = Math.max(10, this.currentSize * 3);
                const angle = Math.atan2(y2 - y1, x2 - x1);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                // arrow head
                ctx.beginPath();
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 - headLen * Math.cos(angle - Math.PI / 6), y2 - headLen * Math.sin(angle - Math.PI / 6));
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 - headLen * Math.cos(angle + Math.PI / 6), y2 - headLen * Math.sin(angle + Math.PI / 6));
                ctx.stroke();
            }

            _drawAxes(ctx, ox, oy, lenX, lenY) {
                // axes lines
                ctx.beginPath();
                ctx.moveTo(ox - lenX, oy);
                ctx.lineTo(ox + lenX, oy);
                ctx.moveTo(ox, oy - lenY);
                ctx.lineTo(ox, oy + lenY);
                ctx.stroke();

                // arrow heads
                const head = Math.max(8, this.currentSize * 2.2);
                const drawHead = (x, y, angle) => {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x - head * Math.cos(angle - Math.PI / 6), y - head * Math.sin(angle - Math.PI / 6));
                    ctx.moveTo(x, y);
                    ctx.lineTo(x - head * Math.cos(angle + Math.PI / 6), y - head * Math.sin(angle + Math.PI / 6));
                    ctx.stroke();
                };
                drawHead(ox + lenX, oy, 0);       // +x
                drawHead(ox - lenX, oy, Math.PI); // -x
                drawHead(ox, oy - lenY, -Math.PI / 2); // +y (upwards screen)
                drawHead(ox, oy + lenY, Math.PI / 2);  // -y (downwards screen)

                // ticks every 50px
                const tick = Math.max(4, this.currentSize);
                for (let x = ox - lenX + 50; x <= ox + lenX - 1; x += 50) {
                    if (Math.abs(x - ox) < 1) continue;
                    ctx.beginPath();
                    ctx.moveTo(x, oy - tick);
                    ctx.lineTo(x, oy + tick);
                    ctx.stroke();
                }
                for (let y = oy - lenY + 50; y <= oy + lenY - 1; y += 50) {
                    if (Math.abs(y - oy) < 1) continue;
                    ctx.beginPath();
                    ctx.moveTo(ox - tick, y);
                    ctx.lineTo(ox + tick, y);
                    ctx.stroke();
                }

                // labels 'x' and 'y'
                const labelOffset = 14 + this.currentSize;
                ctx.save();
                ctx.fillStyle = this.currentColor;
                ctx.font = 'bold 14px Arial';
                ctx.fillText('x', ox + lenX + labelOffset * 0.2, oy - labelOffset * 0.2);
                ctx.fillText('y', ox + labelOffset * 0.2, oy - lenY - labelOffset * 0.2);
                ctx.restore();
            }
        }

        // 文件幕布管理
        class FileCurtainManager {
            constructor() {
                this.curtain = document.getElementById('fileCurtain');
                this.closeBtn = document.getElementById('closeFileBtn');
                this.playPauseBtn = document.getElementById('playPauseBtn');
                this.drawModeBtn = document.getElementById('drawModeBtn');
                this.prevPageBtn = document.getElementById('prevPageBtn');
                this.canvasToggleBtn = document.getElementById('canvasToggleBtn');

                this.isPlaying = false;
                this.isDrawMode = false;
                this.currentPage = 1;
                this.totalPages = 1;

                this.init();
            }

            init() {
                // 关闭按钮
                this.closeBtn.addEventListener('click', () => {
                    this.hide();
                });

                // 播放/暂停按钮
                this.playPauseBtn.addEventListener('click', () => {
                    this.togglePlay();
                });

                // 绘图模式按钮
                this.drawModeBtn.addEventListener('click', () => {
                    this.toggleDrawMode();
                });

                // 上一页按钮
                this.prevPageBtn.addEventListener('click', () => {
                    this.prevPage();
                });

                // 画板开关按钮
                this.canvasToggleBtn.addEventListener('click', () => {
                    if (window.canvasPanelManager) {
                        window.canvasPanelManager.togglePanels();
                    }
                });

                // ESC键关闭
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.curtain.classList.contains('show')) {
                        this.hide();
                    }
                });
            }

            hide() {
                this.curtain.classList.remove('show');
            }






            togglePlay() {
                this.isPlaying = !this.isPlaying;

                if (this.isPlaying) {
                    this.playPauseBtn.innerHTML = '<span class="material-icons">pause</span>';

                    // 这里可以添加播放逻辑

                } else {
                    this.playPauseBtn.innerHTML = '<span class="material-icons">play_arrow</span>';
                    // 这里可以添加暂停逻辑

                }
            }

            toggleDrawMode() {
                this.isDrawMode = !this.isDrawMode;

                if (this.isDrawMode) {
                    this.drawModeBtn.classList.add('active');
                    // 启用绘图模式
                } else {
                    this.drawModeBtn.classList.remove('active');
                    // 禁用绘图模式
                }
            }

            prevPage() {
                if (this.currentPage > 1) {
                    this.currentPage--;
                    this.updatePage();
                }
            }

            // 删除原“下一页”逻辑（已由画板开关取代）

            updatePage() {
                // 这里可以添加页面更新逻辑
                console.log(`当前页面: ${this.currentPage}/${this.totalPages}`);
            }
        }

        // 创建管理器实例
        const bottomToolbar = new BottomToolbarManager();
        const fileCurtain = new FileCurtainManager();

        // 将管理器暴露到全局
        window.bottomToolbar = bottomToolbar;
        window.fileCurtain = fileCurtain;


        class ElasticDialog {
            constructor() {
                this.dialog = document.querySelector('.elastic-dialog');
                this.slider = this.dialog.querySelector('.elastic-slider');
                this.valueDisplay = this.dialog.querySelector('.slider-value');
                this.closeBtn = this.dialog.querySelector('.dialog-close-btn');
                this.cancelBtn = this.dialog.querySelector('.cancel');
                this.confirmBtn = this.dialog.querySelector('.confirm');

                this.currentValue = 0.5;
                this.confirmCallback = null;

                this.initEvents();
            }

            initEvents() {
                // 滑块事件
                this.slider.addEventListener('input', (e) => {
                    this.currentValue = parseFloat(e.target.value);
                    this.valueDisplay.textContent = this.currentValue.toFixed(2);
                });

                // 关闭按钮
                this.closeBtn.addEventListener('click', () => this.hide());
                this.cancelBtn.addEventListener('click', () => this.hide());

                // 确认按钮
                this.confirmBtn.addEventListener('click', () => {
                    if (this.confirmCallback) {
                        this.confirmCallback(this.currentValue);
                    }
                    this.hide();
                });
            }

            show(callback) {
                this.confirmCallback = callback;
                this.dialog.classList.add('show');
            }

            hide() {
                this.dialog.classList.remove('show');
            }

            // 设置默认值
            setDefaultValue(value) {
                this.slider.value = value;
                this.currentValue = value;
                this.valueDisplay.textContent = value.toFixed(2);
            }
        }


        // 在JavaScript中添加面板管理类
        class SpeedForcePanel {
            constructor() {
                this.panel = document.getElementById('speedForcePanel');
                this.isVisible = false;
                this.currentValues = {
                    // 分量
                    hSpeed: 0,
                    vSpeed: 0,
                    hForce: 0,
                    vForce: 0,
                    hSpeedTime: 1,
                    vSpeedTime: 1,
                    hForceTime: 1,
                    vForceTime: 1
                };

                this.initEvents();
            }

            initEvents() {
                // 绑定输入事件并联动显示数值
                const inputs = this.panel.querySelectorAll('input');
                inputs.forEach(input => {
                    input.addEventListener('input', (e) => {
                        this.updateValue(e.target.id, e.target.value);
                        this.syncLabels();
                    });
                });
                // 快捷预设
                this.panel.querySelectorAll('.preset-chip').forEach(chip => {
                    chip.addEventListener('click', () => {
                        const target = chip.getAttribute('data-target');
                        const value = parseFloat(chip.getAttribute('data-value'));
                        const slider = this.panel.querySelector('#' + target);
                        if (slider) {
                            slider.value = value;
                            this.updateValue(target, value);
                            this.syncLabels();
                        }
                    });
                });
                // 步进按钮
                this.panel.querySelectorAll('.step-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const target = btn.getAttribute('data-target');
                        const step = parseFloat(btn.getAttribute('data-step'));
                        const slider = this.panel.querySelector('#' + target);
                        if (slider) {
                            const next = Math.max(parseFloat(slider.min), Math.min(parseFloat(slider.max), parseFloat(slider.value) + step));
                            slider.value = next;
                            this.updateValue(target, next);
                            this.syncLabels();
                        }
                    });
                });
                this.syncLabels();
            }

            updateValue(id, value) {
                switch (id) {
                    case 'horizontalSpeed':
                        this.currentValues.hSpeed = parseFloat(value);
                        break;
                    case 'verticalSpeed':
                        this.currentValues.vSpeed = parseFloat(value);
                        break;
                    case 'horizontalForce':
                        this.currentValues.hForce = parseFloat(value);
                        break;
                    case 'verticalForce':
                        this.currentValues.vForce = parseFloat(value);
                        break;
                    case 'hSpeedTime':
                        this.currentValues.hSpeedTime = parseFloat(value);
                        break;
                    case 'vSpeedTime':
                        this.currentValues.vSpeedTime = parseFloat(value);
                        break;
                    case 'hForceTime':
                        this.currentValues.hForceTime = parseFloat(value);
                        break;
                    case 'vForceTime':
                        this.currentValues.vForceTime = parseFloat(value);
                        break;
                    // removed directional controls
                }
            }

            syncLabels() {
                const get = (id) => this.panel.querySelector('#' + id);
                const setText = (id, val) => { const el = get(id); if (el) el.textContent = String(val); };
                setText('horizontalSpeedVal', this.currentValues.hSpeed);
                setText('verticalSpeedVal', this.currentValues.vSpeed);
                setText('horizontalForceVal', this.currentValues.hForce);
                setText('verticalForceVal', this.currentValues.vForce);
                setText('hSpeedTimeVal', this.currentValues.hSpeedTime);
                setText('vSpeedTimeVal', this.currentValues.vSpeedTime);
                setText('hForceTimeVal', this.currentValues.hForceTime);
                setText('vForceTimeVal', this.currentValues.vForceTime);
            }

            show() {
                this.panel.classList.add('show');
                this.isVisible = true;
                // 右侧展示
                this.panel.style.left = '80%';
                this.panel.style.top = '50%';
                this.panel.style.transform = 'translate(-50%, -50%)';
            }

            hide() {
                this.panel.classList.remove('show');
                this.isVisible = false;
            }

            confirm() {
                const detail = { ...this.currentValues };
                const event = new CustomEvent('speedForceConfirm', { detail });
                document.dispatchEvent(event);
                this.hide();

            }
        }

        document.addEventListener('speedForceConfirm', (e) => {
            const {
                hSpeed, vSpeed, hForce, vForce,
                hSpeedTime, vSpeedTime, hForceTime, vForceTime
            } = e.detail;
            console.log('确认参数：', e.detail);
            setid.push(e.detail);//已经推到数组里
            showFloatingBall();
        });


        // 世界属性设置面板管理类
        class WorldSettingsPanel {
            constructor() {
                this.panel = document.getElementById('worldSettingsPanel');
                this.isVisible = false;
                this.currentValues = {
                    gravity: 1,
                    fieldSize: 0,
                    friction: 0.8,
                    backgroundColor: '#1a1a2e',
                    fps: 60
                };
                this.init();
            }

            init() {
                this.setupDragHandling();
                this.setupSliderEvents();
                this.setupStepperEvents();
                this.setupColorPicker();
                this.updateDisplay();
            }

            setupDragHandling() {
                const dragHandle = this.panel.querySelector('.drag-handle');
                let isDragging = false;
                let startX, startY, initialX, initialY;

                dragHandle.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    initialX = this.panel.offsetLeft;
                    initialY = this.panel.offsetTop;
                    this.panel.classList.add('dragging');
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const deltaX = e.clientX - startX;
                        const deltaY = e.clientY - startY;
                        this.panel.style.left = (initialX + deltaX) + 'px';
                        this.panel.style.top = (initialY + deltaY) + 'px';
                        this.panel.style.transform = 'none';
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        this.panel.classList.remove('dragging');
                    }
                });
            }

            setupSliderEvents() {
                const sliders = this.panel.querySelectorAll('input[type="range"]');
                sliders.forEach(slider => {
                    slider.addEventListener('input', (e) => {
                        const id = e.target.id;
                        const value = parseFloat(e.target.value);

                        switch (id) {
                            case 'gravity':
                                this.currentValues.gravity = value;
                                document.getElementById('gravityVal').textContent = value.toFixed(1);
                                break;
                            case 'fieldSize':
                                this.currentValues.fieldSize = value;
                                document.getElementById('fieldSizeVal').textContent = value.toFixed(1);
                                break;
                            case 'friction':
                                this.currentValues.friction = value;
                                document.getElementById('frictionVal').textContent = value.toFixed(1);
                                break;
                            case 'fps':
                                this.currentValues.fps = value;
                                document.getElementById('fpsVal').textContent = value;
                                break;
                        }
                    });
                });
            }

            setupStepperEvents() {
                const steppers = this.panel.querySelectorAll('.step-btn');
                steppers.forEach(stepper => {
                    stepper.addEventListener('click', (e) => {
                        const target = e.target.getAttribute('data-target');
                        const step = parseFloat(e.target.getAttribute('data-step'));
                        const slider = document.getElementById(target);

                        if (slider) {
                            const currentValue = parseFloat(slider.value);
                            const newValue = Math.max(
                                parseFloat(slider.min),
                                Math.min(parseFloat(slider.max), currentValue + step)
                            );
                            slider.value = newValue;
                            slider.dispatchEvent(new Event('input'));
                        }
                    });
                });
            }

            setupColorPicker() {
                const colorPicker = document.getElementById('backgroundColor');
                colorPicker.addEventListener('change', (e) => {
                    this.currentValues.backgroundColor = e.target.value;
                });
            }

            updateDisplay() {
                // 更新所有显示值
                document.getElementById('gravityVal').textContent = this.currentValues.gravity.toFixed(1);
                document.getElementById('fieldSizeVal').textContent = this.currentValues.fieldSize.toFixed(1);
                document.getElementById('frictionVal').textContent = this.currentValues.friction.toFixed(1);
                document.getElementById('fpsVal').textContent = this.currentValues.fps;

                // 更新滑块值
                document.getElementById('gravity').value = this.currentValues.gravity;
                document.getElementById('fieldSize').value = this.currentValues.fieldSize;
                document.getElementById('friction').value = this.currentValues.friction;
                document.getElementById('fps').value = this.currentValues.fps;
                document.getElementById('backgroundColor').value = this.currentValues.backgroundColor;
            }

            show() {
                this.panel.classList.add('show');
                this.isVisible = true;
            }

            hide() {
                this.panel.classList.remove('show');
                this.isVisible = false;
            }

            confirm() {
                // 应用设置到物理世界
                this.applySettings();

                // 触发确认事件
                const event = new CustomEvent('worldSettingsConfirm', {
                    detail: this.currentValues
                });
                document.dispatchEvent(event);

                this.hide();
            }

            applySettings() {
                // 这里需要根据实际的物理引擎API来应用设置
                // 假设有全局的物理引擎对象
                if (window.__matter && window.__matter.engine) {
                    const engine = window.__matter.engine;

                    // 设置重力（垂直）
                    engine.world.gravity.y = this.currentValues.gravity;

                    // 设置水平场重力
                    engine.world.gravity.x = this.currentValues.fieldSize;


                    // 设置地面摩擦
                    if (window.__matter.ground) {
                        window.__matter.ground.friction = this.currentValues.friction;
                    }

                    // 设置渲染器背景颜色
                    if (window.__matter.render && window.__matter.render.canvas) {
                        window.__matter.render.canvas.style.backgroundColor = this.currentValues.backgroundColor;
                    }

                    // 设置帧数（需要重启渲染循环）
                    if (window.__matter.runner) {
                        // 停止当前循环
                        window.__matter.Engine.clear(window.__matter.runner);

                        // 重新启动循环
                        window.__matter.runner = window.__matter.Runner.create();
                        window.__matter.Runner.run(window.__matter.runner, engine);

                        // 设置新的帧率
                        if (window.__matter.runner.timing) {
                            window.__matter.runner.timing.timestamp = 1000 / this.currentValues.fps;
                        }
                    }
                }

                console.log('世界属性设置已应用:', this.currentValues);
            }
        }

        // 初始化实例
        const speedForcePanel = new SpeedForcePanel();
        const worldSettingsPanel = new WorldSettingsPanel();
        // 暴露控制函数
        window.openSpeedForcePanel = () => speedForcePanel.show();
        window.closeSpeedForcePanel = () => speedForcePanel.hide();
        window.openWorldSettingsPanel = () => worldSettingsPanel.show();
        window.closeWorldSettingsPanel = () => worldSettingsPanel.hide();
        window.awaitSpeedForce = () => new Promise((resolve) => {
            const handler = (e) => {
                document.removeEventListener('speedForceConfirm', handler);
                resolve(e.detail);
            };
            document.addEventListener('speedForceConfirm', handler, { once: true });
            speedForcePanel.show();
        });



        // 悬浮球控制
        (function initFloatingBall() {
            const ball = (() => {
                let el = document.getElementById('floatingBall');
                if (!el) {
                    el = document.createElement('div');
                    el.id = 'floatingBall';
                    el.className = 'floating-ball';
                    el.innerHTML = '<span class="material-icons">bolt</span>';
                    document.body.appendChild(el);
                }
                return el;
            })();

            const handle = (() => {
                let el = document.getElementById('floatingBallHandle');
                if (!el) {
                    el = document.createElement('div');
                    el.id = 'floatingBallHandle';
                    el.className = 'floating-ball-handle';
                    el.textContent = '拖动';
                    document.body.appendChild(el);
                }
                return el;
            })();

            // 点击球本身 -> 隐藏球与手柄
            ball.addEventListener('click', () => {
                ball.classList.remove('show');
                handle.classList.remove('show');

                // 这里写运动逻辑
                for (let i = 0; i < needsetbody.length; i++) {
                    const body = needsetbody[i];
                    const params = setid[i];
                    SetVelocityX(body, params.hSpeed, params.hSpeedTime);
                    SetVelocityY(body, params.vSpeed, params.vSpeedTime);
                    SetForceX(body, params.hForce, params.hForceTime);
                    SetForceY(body, params.vForce, params.vForceTime);

                    let t = 0;
                    const intervalId = setInterval(function () {
                        t += 0.1; // 以0.1s为步长累积时间轴
                        // 在左侧画板绘制 速度-时间 点 (t, vx)
                        window.physicsPlot.plotPoint('left', t, body.velocity.x, body.render.strokeStyle);
                        window.physicsPlot.plotPoint('right', t, body.velocity.y * (-1), body.render.strokeStyle);
                    }, 100);
                    // 如需结束绘制，可在外部保存 intervalId 并在条件满足时 clearInterval(intervalId)
                }



                //清空
                needsetbody = [];
                setid = [];



            });




            // 拖拽逻辑：通过手柄拖动，球与手柄位置保持偏移量
            let dragging = false;
            let offsetX = 0;
            let offsetY = 0;
            const syncHandle = () => {
                const rect = ball.getBoundingClientRect();
                handle.style.left = rect.left + rect.width + 20 + 'px';
                handle.style.top = rect.top + rect.height / 2 + 'px';
                handle.style.transform = 'translate(0, -50%)';
            };

            const onMouseMove = (e) => {
                if (!dragging) return;
                const x = e.clientX - offsetX;
                const y = e.clientY - offsetY;
                ball.style.transform = `translate(0,0)`; // 清除居中位移
                ball.style.left = Math.max(0, Math.min(window.innerWidth - 56, x)) + 'px';
                ball.style.top = Math.max(0, Math.min(window.innerHeight - 56, y)) + 'px';
                ball.style.position = 'fixed';
                syncHandle();
            };

            handle.addEventListener('mousedown', (e) => {
                dragging = true;
                const rect = ball.getBoundingClientRect();
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', () => {
                    dragging = false;
                    document.removeEventListener('mousemove', onMouseMove);
                }, { once: true });
            });

            window.showFloatingBall = () => {
                ball.classList.add('show');
                handle.classList.add('show');
                // 初次显示时手柄贴在球右侧
                setTimeout(syncHandle, 0);
            };
            window.hideFloatingBall = () => {
                ball.classList.remove('show');
                handle.classList.remove('show');
            };
        })();

        /* 使用示例：
        // 显示面板
      
        
        // 监听确认事件
        
        */


        //物理画板
        window.physicsPlot.createAxes('left', { origin: 'center', scale: 40 })
        window.physicsPlot.createAxes('right', { origin: 'center', scale: 40 })
        //描点
        window.physicsPlot.plotPoint('left', 0, 40, '#00ffff')
        window.physicsPlot.plotPoint('right', 0, 40, 'red')
        //自动缩放
        window.physicsPlot.setAutoFit(true) // 开启
        window.physicsPlot.setAutoFit(true) // 关闭

        //显示悬浮球
        // showFloatingBall();
        // hideFloatingBall();//隐藏悬浮球

        function makeDraggable(element, handle) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            handle.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                initialX = element.offsetLeft;
                initialY = element.offsetTop;
                element.classList.add('dragging');
                e.preventDefault();
            });
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    element.style.left = (initialX + deltaX) + 'px';
                    element.style.top = (initialY + deltaY) + 'px';
                    element.style.transform = 'none';
                }
            });
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    element.classList.remove('dragging');
                }
            });
        }

        // 文件命名对话框管理
        class FileNameDialog {
            constructor() {
                this.dialog = document.getElementById('fileNameDialog');
                this.closeBtn = document.getElementById('fileNameCloseBtn');
                this.confirmBtn = document.getElementById('fileNameConfirmBtn');
                this.cancelBtn = document.getElementById('fileNameCancelBtn');
                this.fileNameInput = document.getElementById('sceneFileName');
                this.downloadBtn = document.getElementById('downloadButton');

                this.init();
            }

            init() {
                // 下载按钮点击事件
                this.downloadBtn.addEventListener('click', () => {
                    this.show();
                });

                // 关闭按钮
                this.closeBtn.addEventListener('click', () => this.hide());
                this.cancelBtn.addEventListener('click', () => this.hide());

                // 确认按钮
                this.confirmBtn.addEventListener('click', () => {
                    const fileName = this.fileNameInput.value.trim();
                    if (fileName) {
                        this.downloadScene(fileName);
                        this.hide();
                    } else {
                        window.alertDialog.alert('请输入有效的文件名', '错误', 2000);
                    }
                });

                // 拖拽处理
                const dragHandle = this.dialog.querySelector('.drag-handle');
                makeDraggable(this.dialog, dragHandle);
            }

            show() {
                this.dialog.classList.add('show');
                this.fileNameInput.focus();
            }

            hide() {
                this.dialog.classList.remove('show');
                this.fileNameInput.value = '';
            }

            downloadScene(fileName) {
                try {
                    // 获取当前场景数据
                    const sceneData = this.getCurrentSceneData();

                    // 创建下载链接
                    const blob = new Blob([sceneData], { type: 'text/javascript' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${fileName}.js`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    window.alertDialog.success('场景已保存', '成功', 2000);
                } catch (error) {
                    console.error('保存场景失败:', error);
                    window.alertDialog.alert('保存场景失败: ' + error.message, '错误', 3000);
                }
            }

            getCurrentSceneData() {
                const refs = window.__matter;
                if (!refs) throw new Error('Matter.js 未初始化');

                const { Matter, world } = refs;
                const bodies = Matter.Composite.allBodies(world);
                const constraints = Matter.Composite.allConstraints(world);
                const lines = [];

                lines.push('// 自动生成的场景文件');
                lines.push('// 使用造物主4.0导入');
                lines.push('\nconst world = window.__matter.world;');
                lines.push('const Matter = window.__matter.Matter;');
                lines.push('const createdBodies = new Map();\n');
                lines.push('// 错误处理函数');
                lines.push('function handleError(message, func) {');
                lines.push('  try {');
                lines.push('    return func();');
                lines.push('  } catch (e) {');
                lines.push('    console.warn(message + ": " + e.message);');
                lines.push('    return null;');
                lines.push('  }');
                lines.push('}\n');

                // 创建所有物体
                bodies.forEach((b) => {
                    const opt = {
                        isStatic: !!b.isStatic,
                        restitution: b.restitution,
                        friction: b.friction,
                        frictionAir: b.frictionAir,
                        density: b.density,
                        angle: b.angle,
                        render: b.render
                    };
                    const optStr = JSON.stringify(opt);

                    if (b.circleRadius) {
                        lines.push(`handleError('创建圆形物体', function() {`);
                        lines.push(`    const body = Matter.Bodies.circle(${b.position.x}, ${b.position.y}, ${b.circleRadius}, ${optStr});`);
                        lines.push(`    Matter.World.add(world, body);`);
                        lines.push(`    createdBodies.set('${b.id}', body);`);
                        lines.push(`    return body;`);
                        lines.push(`});`);
                    } else if (b.vertices && b.vertices.length >= 3) {
                        const verts = JSON.stringify(b.vertices.map(v => ({ x: v.x, y: v.y })));
                        lines.push(`handleError('创建多边形物体', function() {`);
                        lines.push(`    const body = Matter.Bodies.fromVertices(${b.position.x}, ${b.position.y}, [${verts}], ${optStr}, true, 0.01, 10);`);
                        lines.push(`    Matter.World.add(world, body);`);
                        lines.push(`    createdBodies.set('${b.id}', body);`);
                        lines.push(`    return body;`);
                        lines.push(`});`);
                    }
                });

                // 创建所有约束
                constraints.forEach((c, index) => {
                    lines.push(`handleError('创建约束 #${index}', function() {`);
                    lines.push(`    // 确保两个物体都存在`);
                    lines.push(`    const bodyA = ${c.bodyA ? `createdBodies.get('${c.bodyA.id}')` : 'null'};`);
                    lines.push(`    const bodyB = ${c.bodyB ? `createdBodies.get('${c.bodyB.id}')` : 'null'};`);
                    lines.push(`    if (bodyA === undefined || bodyB === undefined) return null;`);
                    
                    const arr = [];
                    if (c.bodyA) arr.push(`bodyA: bodyA`);
                    if (c.bodyB) arr.push(`bodyB: bodyB`);
                    if (c.pointA) arr.push(`pointA: {x:${c.pointA.x}, y:${c.pointA.y}}`);
                    if (c.pointB) arr.push(`pointB: {x:${c.pointB.x}, y:${c.pointB.y}}`);
                    if (typeof c.length !== 'undefined') arr.push(`length:${c.length}`);
                    if (typeof c.stiffness !== 'undefined') arr.push(`stiffness:${c.stiffness}`);
                    if (typeof c.damping !== 'undefined') arr.push(`damping:${c.damping}`);
                    if (typeof c.angleA !== 'undefined') arr.push(`angleA:${c.angleA}`);
                    if (typeof c.angleB !== 'undefined') arr.push(`angleB:${c.angleB}`);
                    if (typeof c.knockback !== 'undefined') arr.push(`knockback:${c.knockback}`);
                    if (typeof c.render !== 'undefined' && c.render) arr.push(`render:${JSON.stringify(c.render)}`);

                    const optStr = `{ ${arr.join(', ')} }`;
                    lines.push(`    const cons = Matter.Constraint.create(${optStr});`);
                    lines.push(`    Matter.World.add(world, cons);`);
                    lines.push(`    return cons;`);
                    lines.push(`});`);
                });

                return lines.join('\n');
            }
        }

        // 初始化文件命名对话框
        const fileNameDialog = new FileNameDialog();

        // 代码编辑器管理
        class CodeEditorManager {
            constructor() {
                this.panel = document.getElementById('codeEditorPanel');
                this.codeButton = document.getElementById('codeButton');
                this.closeButton = document.getElementById('codeEditorCloseBtn');
                this.runButton = document.getElementById('codeEditorRunBtn');
                this.clearButton = document.getElementById('codeEditorClearBtn');
                this.editor = document.getElementById('codeEditor');
                this.isVisible = false;

                this.init();
            }

            init() {
                // 代码按钮点击事件
                this.codeButton.addEventListener('click', () => {
                    this.toggle();
                });

                // 关闭按钮
                this.closeButton.addEventListener('click', () => {
                    this.hide();
                });

                // 运行按钮
                this.runButton.addEventListener('click', () => {
                    this.runCode();
                });

                // 清空按钮
                this.clearButton.addEventListener('click', () => {
                    this.editor.value = '';
                });

                // 点击面板外部关闭
                this.panel.addEventListener('click', (e) => {
                    e.stopPropagation();
                });

                document.addEventListener('click', (e) => {
                    if (this.isVisible && !this.panel.contains(e.target) && !this.codeButton.contains(e.target)) {
                        this.hide();
                    }
                });

                // 初始化拖拽
                this.initDrag();
            }

            initDrag() {
                const dragHandle = this.panel.querySelector('.drag-handle');
                let isDragging = false;
                let startX, startY, initialX, initialY;

                dragHandle.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    initialX = this.panel.offsetLeft;
                    initialY = this.panel.offsetTop;
                    this.panel.classList.add('dragging');
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const deltaX = e.clientX - startX;
                        const deltaY = e.clientY - startY;
                        this.panel.style.left = (initialX + deltaX) + 'px';
                        this.panel.style.top = (initialY + deltaY) + 'px';
                        this.panel.style.transform = 'none';
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        this.panel.classList.remove('dragging');
                    }
                });
            }

            runCode() {
                const code = this.editor.value.trim();
                if (!code) return;

                try {
                    // 使用Function构造函数而不是eval，更安全
                    new Function(code)();
                    // window.alertDialog.success('代码执行成功', '成功', 2000);
                } catch (error) {
                    console.error('代码执行错误:', error);
                    window.alertDialog.error(`执行错误: ${error.message}`, '错误', 3000);
                }
            }

            toggle() {
                if (this.isVisible) {
                    this.hide();
                } else {
                    this.show();
                }
            }

            show() {
                this.panel.classList.add('show');
                this.codeButton.classList.add('active');
                this.isVisible = true;
                this.editor.focus();
            }

            hide() {
                this.panel.classList.remove('show');
                this.codeButton.classList.remove('active');
                this.isVisible = false;
            }
        }

        // 初始化代码编辑器
        const codeEditor = new CodeEditorManager();

        // 完全删除现有实例并重新初始化
        delete window.elasticDialog;
        delete window.showElasticDialog;
        delete window._elasticDialogInitialized;

        // 使用立即执行函数封装，避免变量污染
        (function () {
            // 确保只初始化一次
            if (!window._elasticDialogInitialized) {
                window._elasticDialogInitialized = true;

                class ElasticDialog {
                    constructor() {
                        // 检查元素是否存在
                        if (!document.getElementById('elasticDialog')) {
                            console.error('elasticDialog element not found');
                            return;
                        }

                        this.dialog = document.getElementById('elasticDialog');
                        this.slider = document.getElementById('elasticSlider');
                        this.valueDisplay = document.getElementById('elasticValue');
                        this.closeBtn = document.getElementById('elasticCloseBtn');
                        this.cancelBtn = document.getElementById('elasticCancelBtn');
                        this.confirmBtn = document.getElementById('elasticConfirmBtn');

                        this.currentValue = 0.5;
                        this.confirmCallback = null;

                        // 确保元素都存在再初始化事件
                        if (this.slider && this.valueDisplay) {
                            this.initEvents();
                        } else {
                            console.error('Required elements for ElasticDialog not found');
                        }
                    }

                    initEvents() {
                        // 滑块事件
                        this.slider.addEventListener('input', (e) => {
                            this.currentValue = parseFloat(e.target.value);
                            this.valueDisplay.textContent = this.currentValue.toFixed(1);
                        });

                        // 关闭按钮
                        this.closeBtn.addEventListener('click', () => this.hide());
                        this.cancelBtn.addEventListener('click', () => this.hide());

                        // 确认按钮
                        this.confirmBtn.addEventListener('click', () => {
                            if (this.confirmCallback) {
                                this.confirmCallback(this.currentValue);
                            }
                            this.hide();
                        });

                        // 拖拽处理
                        const dragHandle = this.dialog.querySelector('.drag-handle');
                        let isDragging = false;
                        let startX, startY, initialX, initialY;

                        dragHandle.addEventListener('mousedown', (e) => {
                            isDragging = true;
                            startX = e.clientX;
                            startY = e.clientY;
                            initialX = this.dialog.offsetLeft;
                            initialY = this.dialog.offsetTop;
                            this.dialog.classList.add('dragging');
                            e.preventDefault();
                        });

                        document.addEventListener('mousemove', (e) => {
                            if (isDragging) {
                                const deltaX = e.clientX - startX;
                                const deltaY = e.clientY - startY;
                                this.dialog.style.left = (initialX + deltaX) + 'px';
                                this.dialog.style.top = (initialY + deltaY) + 'px';
                                this.dialog.style.transform = 'none';
                            }
                        });

                        document.addEventListener('mouseup', () => {
                            if (isDragging) {
                                isDragging = false;
                                this.dialog.classList.remove('dragging');
                            }
                        });
                    }

                    show(callback) {
                        this.confirmCallback = callback;
                        this.dialog.classList.add('show');
                    }

                    hide() {
                        this.dialog.classList.remove('show');
                    }

                    setDefaultValue(value) {
                        if (this.slider && this.valueDisplay) {
                            this.slider.value = value;
                            this.currentValue = value;
                            this.valueDisplay.textContent = value.toFixed(1);
                        }
                    }
                }

                // 安全初始化
                try {
                    window.elasticDialog = new ElasticDialog();
                } catch (e) {
                    console.error('Failed to initialize ElasticDialog:', e);
                }

                // 安全的全局调用方法
                window.showElasticDialog = function (callback, defaultValue = 0.5) {
                    // 确保 elasticDialog 已初始化且有 setDefaultValue 方法
                    if (window.elasticDialog && typeof window.elasticDialog.setDefaultValue === 'function') {
                        window.elasticDialog.setDefaultValue(defaultValue);
                        window.elasticDialog.show(callback);
                    } else {
                        console.error('ElasticDialog not properly initialized');
                        // 可以在这里添加备用方案或重试逻辑
                    }
                };
            }


        })();




        window.alertDialog.success('感谢您的使用--造物主内测版本', '欢迎', 5000);
    </script>
    <script src="/zwz/function.js"></script>
    <script src="/zwz/show.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="/zwz/additem.js"></script>

</body>

</html>
